// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "c.h"
#include "postgres.h"
#include <cstring>


#include "DataPageAccess.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include "storage/fd.h"
#include "commands/tablespace.h"
#include "storage/rpcserver.h"
#include "storage/bufmgr.h"
#include <sys/stat.h>
#include "storage/copydir.h"
#include "storage/md.h"
#include "catalog/catalog.h"
#include "utils/relcache.h"
#include "storage/smgr.h"
#include "utils/rel.h"
#include "tcop/storage_server.h"
#include "access/logindex_hashmap.h"
#include "replication/walreceiver.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::tutorial;
class DataPageAccessHandler : virtual public DataPageAccessIf {
public:
    DataPageAccessHandler() {
        // Your initialization goes here
    }

    /**
     * A method definition looks like C code. It has a return type, arguments,
     * and optionally a list of exceptions that it may throw. Note that argument
     * lists and exception lists are specified using the exact same syntax as
     * field lists in struct or exception definitions.
     *
     * @param _fd
     */
    void ReadBufferCommon(_Page& _return, const _Smgr_Relation& _reln, const int32_t _relpersistence, const int32_t _forknum, const int32_t _blknum, const int32_t _readBufferMode) {
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blkNum = %d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum);
        fflush(stdout);
        // Your implementation goes here
        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

        char buff[BLCKSZ];
        GetPageByLsn(rnode, (ForkNumber)_forknum, _blknum, 0, buff);
        _return.assign(buff, BLCKSZ);

        if(PageIsNew(buff)) {
            printf("%s found page is new\n", __func__ );
            fflush(stdout);
        }
        printf("%s End\n", __func__ );
//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
//
//        char relpersistence = (char) _relpersistence;
//        bool hit;
//        char* page;
//
//        Buffer buff = ReadBuffer_common(smgrReln, relpersistence, (ForkNumber)_forknum, (BlockNumber)_blknum, (ReadBufferMode)_readBufferMode, NULL, &hit);
//        LockBuffer(buff, BUFFER_LOCK_SHARE);
//        page = BufferGetPage(buff);
//        _return.assign(page, BLCKSZ);
//
//        UnlockReleaseBuffer(buff);
    }

    void RpcMdRead(_Page& _return, const _Smgr_Relation& _reln, const int32_t _forknum, const int64_t _blknum) {
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blkNum = %ld\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum);
        fflush(stdout);
        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;
        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);


        char buff[BLCKSZ];
        GetPageByLsn(rnode, (ForkNumber)_forknum, _blknum, 0, buff);
        _return.assign(buff, BLCKSZ);

        printf("%s End\n", __func__ );
//        RelationData relationData;
//        memset(&relationData, 0, sizeof(RelationData));
//        Relation relation = &relationData;
//        relation->rd_smgr = smgrReln;

        // Not guarantee right
//        FormData_pg_class formDataPgClass;
//        formDataPgClass.relpersistence = RELPERSISTENCE_PERMANENT;
//        relation->rd_rel = &formDataPgClass;
//
//        Buffer buff = ReadBufferExtended(relation, (ForkNumber)_forknum, _blknum, RBM_NORMAL, NULL);
//
//        LockBuffer(buff, BUFFER_LOCK_SHARE);
//        char* page;
//        page = BufferGetPage(buff);
//
//        char tempPage[BLCKSZ];
//        memcpy(tempPage, page, BLCKSZ);
//
//        _return.resize(BLCKSZ);
//        _return.assign(tempPage, BLCKSZ);
//
//        UnlockReleaseBuffer(buff);

//        char page[BLCKSZ+16];
//        mdread(smgrReln, (ForkNumber)_forknum, _blknum, page);
//        _return.assign(page, BLCKSZ);
//
//        printf("%s end\n", __func__ );
//        fflush(stdout);
    }

    int32_t RpcMdNblocks(const _Smgr_Relation& _reln, const int32_t _forknum) {
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, gettid());
        fflush(stdout);
        // Your implementation goes here
//        SyncReplayProcess();

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;
        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);

        XLogRecPtr lsn = WalRcv->flushedUpto;
        struct KeyType keyType;
        keyType.SpcID = rnode.spcNode;
        keyType.DbID = rnode.dbNode;
        keyType.RelID = rnode.relNode;
        keyType.ForkNum = _forknum;

        uint64_t foundLsn;
        int foundPageNum;

        if ( HashMapFindLowerBoundEntry(keyType, lsn, &foundLsn, &foundPageNum) ) {
            printf("%s cached, lsn = %lu, pageNum = %d\n", __func__ , foundLsn, foundPageNum);
            return foundPageNum;
        }

        int relSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, 0);
        printf("%s get relsize=%d from standalone pg\n", __func__ , relSize);
        bool insertSucc = HashMapInsertKey(keyType, lsn, relSize);
        if(insertSucc) {
            printf("%s insert key successfully\n", __func__ );
        } else {
            printf("%s insert key failed\n", __func__ );
        }

//        BlockNumber result = mdnblocks(smgrReln, (ForkNumber)_forknum);
        printf("%s end\n", __func__ );
        fflush(stdout);
        return relSize;
    }

    int32_t RpcMdExists(const _Smgr_Relation& _reln, const int32_t _forknum) {
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, gettid());
        fflush(stdout);

//        SyncReplayProcess();

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

        struct KeyType key{};
        key.SpcID = rnode.spcNode;
        key.DbID = rnode.dbNode;
        key.RelID = rnode.relNode;
        key.ForkNum = _forknum;

        uint64_t foundLsn;
        int foundPageNum;
        int found = HashMapFindLowerBoundEntry(key, WalRcv->flushedUpto, &foundLsn, &foundPageNum);
        if(found) {
            if(foundPageNum == -1)
                return 0;
            else
                return 1;
        }

//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
//        int32_t result = mdexists(smgrReln, (ForkNumber)_forknum);

        int relSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, WalRcv->flushedUpto);
        printf("%s get relsize=%d from standalone pg\n", __func__ , relSize);
        bool insertSucc = HashMapInsertKey(key, WalRcv->flushedUpto, relSize);
        if(insertSucc) {
            printf("%s insert key successfully\n", __func__ );
        } else {
            printf("%s insert key failed\n", __func__ );
        }

        printf("%s result = %d end\n", __func__, relSize);
        fflush(stdout);
        return (relSize>=0);
    }

    void RpcMdCreate(const _Smgr_Relation& _reln, const int32_t _forknum, const int32_t _isRedo) {
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, gettid());
        fflush(stdout);

//        SyncReplayProcess();

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

        struct KeyType key{};
        key.SpcID = rnode.spcNode;
        key.DbID = rnode.dbNode;
        key.RelID = rnode.relNode;
        key.ForkNum = _forknum;

        uint64_t foundLsn;
        int foundPageNum;
        int found = HashMapFindLowerBoundEntry(key, WalRcv->flushedUpto, &foundLsn, &foundPageNum);
        if(!found || foundPageNum<0) {
            if (HashMapInsertKey(key, WalRcv->flushedUpto, 0) )
                printf("%s HashMap insert succeed\n", __func__ );
            else
                printf("%s HashMap insert failed\n", __func__ );
        }

//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
//        mdcreate(smgrReln, (ForkNumber)_forknum, _isRedo);
        printf("%s end\n", __func__);
        fflush(stdout);
    }

    void RpcMdExtend(const _Smgr_Relation& _reln, const int32_t _forknum, const int32_t _blknum, const _Page& _buff, const int32_t skipFsync) {
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, gettid());
        fflush(stdout);

//        SyncReplayProcess();

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

        struct KeyType key{};
        key.SpcID = rnode.spcNode;
        key.DbID = rnode.dbNode;
        key.RelID = rnode.relNode;
        key.ForkNum = _forknum;

        uint64_t foundLsn;
        int foundPageNum;
        int found = HashMapFindLowerBoundEntry(key, WalRcv->flushedUpto, &foundLsn, &foundPageNum);
        if(!found || foundPageNum<_blknum+1) {
            if (HashMapInsertKey(key, WalRcv->flushedUpto, _blknum+1) )
                printf("%s HashMap insert succeed\n", __func__ );
            else
                printf("%s HashMap insert failed\n", __func__ );
        }

//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
//        char extendPage[BLCKSZ+16];
//        _buff.copy(extendPage, BLCKSZ);
//
//        mdextend(smgrReln, (ForkNumber)_forknum, (BlockNumber)_blknum, extendPage, skipFsync);
        printf("%s end\n", __func__);
        fflush(stdout);
    }
    /**
     * This method has a oneway modifier. That means the client only makes
     * a request and does not listen for any response at all. Oneway methods
     * must be void.
     */
    void zip() {
        // Your implementation goes here
        printf("zip\n");
    }

};


void
RpcServerLoop(void){
    int port = 9090;

    std::shared_ptr<concurrency::ThreadFactory> threadFactory = std::make_shared<concurrency::ThreadFactory>(new concurrency::ThreadFactory());
//    std::shared_ptr<concurrency::ThreadManager> threadManager = concurrency::ThreadManager::newThreadManager();
    std::shared_ptr<concurrency::ThreadManager> threadManager = concurrency::ThreadManager::newSimpleThreadManager(50);
    threadManager->threadFactory(threadFactory);
    threadManager->start();


//    TSimpleServer server(
//    TThreadedServer server(
    std::shared_ptr<server::TServer> server;
    server.reset ( new TThreadPoolServer(
            std::make_shared<DataPageAccessProcessor>(std::make_shared<DataPageAccessHandler>()),
            std::make_shared<TServerSocket>(port), //port
            std::make_shared<TBufferedTransportFactory>(),
            std::make_shared<TBinaryProtocolFactory>(),
            threadManager
            ) );

    concurrency::ThreadFactory factory;
    factory.setDetached(false);
    std::shared_ptr<apache::thrift::concurrency::Runnable> serverThreadRunner(server);
    std::shared_ptr<apache::thrift::concurrency::Thread> thread = factory.newThread(serverThreadRunner);
    thread->start();
    concurrency::Monitor gMonitor;
    gMonitor.waitForever();

    server->stop();
    thread->join();
    server.reset();
}
