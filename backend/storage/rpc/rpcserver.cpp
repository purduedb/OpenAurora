// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "DataPageAccess.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include "storage/rpcserver.h"

#include "postgres.h"

#include <unistd.h>
#include <fcntl.h>
#include <sys/file.h>

#include "access/xlog.h"
#include "access/xlogutils.h"
#include "commands/tablespace.h"
#include "miscadmin.h"
#include "pg_trace.h"
#include "pgstat.h"
#include "postmaster/bgwriter.h"
#include "storage/bufmgr.h"
#include "storage/fd.h"
#include "storage/md.h"
#include "storage/relfilenode.h"
#include "storage/smgr.h"
#include "storage/sync.h"
#include "utils/hsearch.h"
#include "utils/memutils.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::tutorial;

class DataPageAccessHandler : virtual public DataPageAccessIf {
 public:
  DataPageAccessHandler() = default;

  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param fd
   */
  void RpcFileClose(const File fd) {
    FileClose(v->mdfd_vfd);
    cout << "RpcFileClose" << endl;
  }

  File RpcFileCreate(const _RelFileNode& node, const _ForkNumber::type forkNum) {
    RelFileNode filenode;

    filenode.spcNode = node::spcNode;
    filenode.dbNode = node::dbNode;
    filenode.relNode = node::relNode;
    
    /*
	 * We may be using the target table space for the first time in this
	 * database, so create a per-database subdirectory if needed.
	 *
	 * XXX this is a fairly ugly violation of module layering, but this seems
	 * to be the best place to put the check.  Maybe TablespaceCreateDbspace
	 * should be here and not in commands/tablespace.c?  But that would imply
	 * importing a lot of stuff that smgr.c oughtn't know, either.
	 */
	  TablespaceCreateDbspace(filenode.spcNode,
							filenode.dbNode,
							false);

	  path = relpathbackend(filenode, InvalidBackendId, forkNum);

	  fd = PathNameOpenFile(path, O_RDWR | O_CREAT | O_EXCL | PG_BINARY);

	  if (fd < 0)
	  {
		  int			save_errno = errno;

		  if (false)
		  	fd = PathNameOpenFile(path, O_RDWR | PG_BINARY);
		  if (fd < 0)
		  {
		  	cout << "Create Error" << endl;
		  }
	  }

	  pfree(path);
    cout << "RpcFileCreate" << endl;
  }

  void RpcFileUnlink(const _RelFileNode& node, const _ForkNumber::type forkNum) {
    RelFileNodeBackend nodebackend;

    nodebackend.node.spcNode = node::spcNode;
    nodebackend.node.dbNode = node::dbNode;
    nodebackend.node.relNode = node::relNode;
    nodebackend.backend = InvalidBackendId;

    mdunlink(nodebackend, forkNum, false);
    cout << "RpcFileUnlink" << endl;
  }

  void RpcFileExtend(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum) {
    // Your implementation goes here
    cout << "RpcFileExtend" << endl;
  }

  void RpcFileRead(_Page& _return, const File fd, const _BlockNumber blocknum) {
    off_t		seekpos;
    BlockNumber _blocknum = blocknum;
    int nbytes;
    char buffer[BLCKSZ];

    seekpos = (off_t) BLCKSZ * (_blocknum % ((BlockNumber) RELSEG_SIZE));

    nbytes = FileRead(fd, buffer, BLCKSZ, seekpos, WAIT_EVENT_DATA_FILE_READ);

    _return::content.assign(buffer, nbytes);

    cout << "RpcFileRead" << endl;
  }

  void RpcFileWrite(const File fd, const _Page& page, const _BlockNumber blocknum) {
    off_t		seekpos;
    BlockNumber _blocknum = blocknum;
    int nbytes;
    char buffer[BLCKSZ];

    page::content.copy(buffer, BLCKSZ);

    seekpos = (off_t) BLCKSZ * (_blocknum % ((BlockNumber) RELSEG_SIZE));

    nbytes = FileWrite(fd, buffer, BLCKSZ, seekpos, WAIT_EVENT_DATA_FILE_WRITE);

    cout << "RpcFileWrite" << endl;
  }

  _BlockNumber RpcFileNblocks(const _RelFileNode& node, const _ForkNumber::type forkNum) {
    // Your implementation goes here
    cout << "RpcFileNblocks"<< endl;
  }

  void RpcFileTruncate(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum) {
    // Your implementation goes here
    cout << "RpcFileTruncate" << endl;
  }

  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  void zip() {
    // Your implementation goes here
    printf("zip\n");
  }

};

void
RpcServerLoop(void)
  int port = 9090;
  ::std::shared_ptr<DataPageAccessHandler> handler(new DataPageAccessHandler());
  ::std::shared_ptr<TProcessor> processor(new DataPageAccessProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

