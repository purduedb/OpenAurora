// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "c.h"
#include "postgres.h"
#include <cstring>


#include "DataPageAccess.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include "storage/fd.h"
#include "commands/tablespace.h"
#include "storage/rpcserver.h"
#include "storage/bufmgr.h"
#include <sys/stat.h>
#include "storage/copydir.h"
#include "storage/md.h"
#include "catalog/catalog.h"
#include "utils/relcache.h"
#include "storage/smgr.h"
#include "utils/rel.h"
#include "tcop/storage_server.h"
#include "access/logindex_hashmap.h"
#include "access/wakeup_latch.h"
#include "replication/walreceiver.h"
#include "storage/kv_interface.h"
#include "storage/buf_internals.h"
#include "access/xlog.h"
#include "pgstat.h"
#include "storage/rel_cache.h"
#include <sys/time.h>

extern HashMap pageVersionHashMap;

extern int reachXlogTempEnd;
extern int XLOGbuffers;

extern XLogRecPtr *RpcXlblocks;
extern char* RpcXLogPages;
extern pthread_rwlock_t *RpcXLogPagesLocks;

extern uint64_t RpcXLogFlushedLsn;


//#define DEBUG_TIMING 1
//#define INFO_FUNC_START
//#define INFO_FUNC_START2
//#define INFO_FUNC_END
//#define ENABLE_DEBUG_INFO
//#define ENABLE_DEBUG_INFO2
//#define RECORD_LSN_INFO

//#define ENABLE_FUNCTION_TIMING

#ifdef ENABLE_FUNCTION_TIMING
#include <sys/time.h>
#include <pthread.h>
#include <cstdlib>

class FunctionTiming {
public:
    struct timeval start;
    struct timeval reTiming;
    char* funcname;
    FunctionTiming(char* paraFuncName) {
        funcname = paraFuncName;
        gettimeofday(&start, NULL);
        gettimeofday(&reTiming, NULL);
    }

    void RecordTime(int lineNum) {
        struct timeval tempTiming;
        gettimeofday(&tempTiming, NULL);
        printf("%s%d function timeing = %ld us\n", funcname, lineNum,
               (tempTiming.tv_sec*1000000+tempTiming.tv_usec) - (reTiming.tv_sec*1000000+reTiming.tv_usec));
        fflush(stdout);

        gettimeofday(&reTiming, NULL);
    }

    inline ~FunctionTiming() {
        struct timeval end;
        gettimeofday(&end, NULL);
        printf("%s function timeing = %ld us\n", funcname,
               (end.tv_sec*1000000+end.tv_usec) - (start.tv_sec*1000000+start.tv_usec));
        fflush(stdout);
    }
};
#endif

//#define DEBUG_TIMING2 1
#ifdef DEBUG_TIMING2

#include <sys/time.h>
#include <pthread.h>
#include <stdlib.h>

#define START_TIMING(start_p)  \
do {                         \
    gettimeofday(start_p, NULL); \
} while(0);

#define RECORD_TIMING(start_p, end_p, info_string) \
do { \
    gettimeofday(end_p, NULL);                     \
    uint64 diff = (*end_p.tv_sec*1000000+*end_p.tv_usec) - (*start_p.tv_sec*1000000+*start_p.tv_usec); \
    printf("%s, timing = %lu us\n", info_string, diff);                                                \
    fflush(stdout);                                               \
    gettimeofday(start_p, NULL); \
} while (0);


#endif

//extern XLogRecPtr XLogParseUpto;

static void TransRelNode2RelKey(RelFileNode node, RelKey *relKey, ForkNumber forkNumber) {
    relKey->SpcId = node.spcNode;
    relKey->DbId = node.dbNode;
    relKey->RelId = node.relNode;

    relKey->forkNum = forkNumber;
    return;
}

pthread_mutex_t wakeupMutex;
void WaitParse(int64_t _lsn) {
#ifdef RECORD_LSN_INFO
    struct timeval now;
    gettimeofday(&now, NULL);
    printf("parameter_lsn = %lu, second = %lu, us = %lu\n",
           _lsn, now.tv_sec, now.tv_usec);
    fflush(stdout);
#endif
//    if(WalRcvRunning() == false)
//        return;
//    XLogRecPtr flushUpto = WalRcv->flushedUpto;
//    if((XLogRecPtr)_lsn > XLogParseUpto && XLogParseUpto < flushUpto && XLogParseUpto != 0) {
    XLogRecPtr replayedLsn = GetWalLastReplayedLsn();


    //! When the server is just started, the FlushedLSN is uninitialized, so we should not wait
    if((XLogRecPtr)_lsn > replayedLsn &&  RpcXLogFlushedLsn != 0) {
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
               __func__ , __LINE__, _lsn, XLogParseUpto, RpcXLogFlushedLsn);
        fflush(stdout);
#endif
//        printf("%s %d , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
//               __func__ , __LINE__, _lsn, XLogParseUpto, RpcXLogFlushedLsn);
//        fflush(stdout);
        XLogRecPtr targetLsn = RpcXLogFlushedLsn;
        if(_lsn < targetLsn)
            targetLsn = _lsn;

        XLogRecPtr prevParse = replayedLsn;

        int count = 0;
        while(replayedLsn < targetLsn-8192) {
            if (count >= 500) {
                printf("%s %d, clog lsn = %lu, target lsn = %lu, count = %d\n", __func__ ,
                       __LINE__, replayedLsn, targetLsn, count);
                fflush(stdout);
                count = 0;
            } else {
                count ++;
            }

//            if(count == 4) {
//                XLogParseUpto = targetLsn;
//            }
//            printf("%s %d keep waiting , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
//                   __func__ , __LINE__, _lsn, XLogParseUpto, flushUpto);
//            fflush(stdout);
#ifdef ENABLE_DEBUG_INFO
            count++;
            if(count % 10 == 0) {
                printf("%s %d keep waiting , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
                       __func__ , __LINE__, _lsn, XLogParseUpto, RpcXLogFlushedLsn);
                fflush(stdout);
                count = 0;
            }
#endif

//            printf("%s get into sleep\n", __func__ );
//            fflush(stdout);
            usleep(500);
//            pthread_mutex_lock(&wakeupMutex);
//            WakeupRecovery();
//            WakeupStartupRecovery();
//            pthread_mutex_unlock(&wakeupMutex);
//            if(reachXlogTempEnd && XLogParseUpto != prevParse) {
//                reachXlogTempEnd = 0;
//            }
//            if(reachXlogTempEnd) {
//                waitCount++;
//            }
            replayedLsn = GetWalLastReplayedLsn();
        }

        if(reachXlogTempEnd) {
            reachXlogTempEnd = 0;
        }
    }
//    printf("%s %d exit\n" ,__func__ , __LINE__);
//    fflush(stdout);
}

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::tutorial;
class DataPageAccessHandler : virtual public DataPageAccessIf {
public:
    DataPageAccessHandler() {
        // Your initialization goes here
    }

    /**
     * A method definition looks like C code. It has a return type, arguments,
     * and optionally a list of exceptions that it may throw. Note that argument
     * lists and exception lists are specified using the exact same syntax as
     * field lists in struct or exception definitions.
     *
     * @param _fd
     */
     void ReadBufferCommon(_Page& _return, const _Smgr_Relation& _reln, const int32_t _relpersistence, const int32_t _forknum, const int32_t _blknum, const int32_t _readBufferMode, const int64_t _lsn) {
#ifdef INFO_FUNC_START
        printf("%s, spc = %lu, db = %lu, rel = %lu, fork = %d, blk = %lu, lsn = %lu\n", __func__ , _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn);
         fflush(stdout);
#endif
#ifdef DEBUG_TIMING2
        struct timeval start, end;
        START_TIMING(&start);
#endif
        WaitParse(_lsn);

#ifdef DEBUG_TIMING2
        RECORD_TIMING(&start, &end, "WaitParse");
#endif
        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

        KeyType key;
        key.SpcID = _reln._spc_node;
        key.DbID = _reln._db_node;
        key.RelID = _reln._rel_node;
        key.ForkNum = _forknum;
        key.BlkNum = _blknum;
//
//        uint64_t foundLsn;
//        int ignored;
//        bool foundBasePage = HashMapFindLowerBoundEntry(pageVersionHashMap, key, _lsn, &foundLsn, &ignored);
//
//        // If not found basePage, get the base page from standalone process
//        if(!foundBasePage) {
//
//            BufferTag bufferTag;
//            INIT_BUFFERTAG(bufferTag, rnode, (ForkNumber) _forknum, (BlockNumber) _blknum);
//            char *buff = (char *) malloc(BLCKSZ);
//            GetBasePage(rnode, (ForkNumber) _forknum, (BlockNumber) _blknum, buff);
//
//            XLogRecPtr lsn = PageGetLSN(buff);
//
//            // (map, key, lsn, pageNum, noEnptySlot); // for pageVersionHashMap, pageNum should always be -1
//            HashMapInsertKey(pageVersionHashMap, key, 1, -1, 1);
//            HashMapUpdateReplayedLsn(pageVersionHashMap, key, 1, false);
//
//            PutPage2Rocksdb(bufferTag, 1, buff);
//
//            // Set return value from RPC client
//            _return.assign(buff, BLCKSZ);
//
//            free(buff);
//
//            return;
//        }
//
        char* targetPage = (char*) malloc(BLCKSZ);
//
//        uint64_t lsn = HashMapGetReplayedLsn(pageVersionHashMap, key);

        GetBasePage(rnode, (ForkNumber) _forknum, (BlockNumber) _blknum, targetPage);

        // Set return value from RPC client
        _return.assign(targetPage, BLCKSZ);

        free(targetPage);
#ifdef DEBUG_TIMING2
        RECORD_TIMING(&start, &end, "GetPage");
#endif
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
        return;

    }

    void RpcMdRead(_Page& _return, const _Smgr_Relation& _reln, const int32_t _forknum, const int64_t _blknum, const int64_t _lsn) {
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blkNum = %ld\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum);
        fflush(stdout);
#endif
        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;
        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);

        WaitParse(_lsn);

        char buff[BLCKSZ];
        GetPageByLsn(rnode, (ForkNumber)_forknum, _blknum, 0, buff);
        _return.assign(buff, BLCKSZ);

#ifdef ENABLE_DEBUG_INFO
        printf("%s End\n", __func__ );
#endif
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
//        RelationData relationData;
//        memset(&relationData, 0, sizeof(RelationData));
//        Relation relation = &relationData;
//        relation->rd_smgr = smgrReln;

        // Not guarantee right
//        FormData_pg_class formDataPgClass;
//        formDataPgClass.relpersistence = RELPERSISTENCE_PERMANENT;
//        relation->rd_rel = &formDataPgClass;
//
//        Buffer buff = ReadBufferExtended(relation, (ForkNumber)_forknum, _blknum, RBM_NORMAL, NULL);
//
//        LockBuffer(buff, BUFFER_LOCK_SHARE);
//        char* page;
//        page = BufferGetPage(buff);
//
//        char tempPage[BLCKSZ];
//        memcpy(tempPage, page, BLCKSZ);
//
//        _return.resize(BLCKSZ);
//        _return.assign(tempPage, BLCKSZ);
//
//        UnlockReleaseBuffer(buff);

//        char page[BLCKSZ+16];
//        mdread(smgrReln, (ForkNumber)_forknum, _blknum, page);
//        _return.assign(page, BLCKSZ);
//
//        printf("%s end\n", __func__ );
//        fflush(stdout);
    }

    int32_t RpcMdNblocks(const _Smgr_Relation& _reln, const int32_t _forknum, const int64_t _lsn) {
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO2
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, lsn = %ld tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _lsn, gettid());
        fflush(stdout);
#endif
        // Your implementation goes here
//        SyncReplayProcess();

#ifdef DEBUG_TIMING
        struct timeval start, end;
        START_TIMING(&start);
#endif
        WaitParse(_lsn);

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &nblocksTime[4], &nblocksCount[4])
#endif
        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

        XLogRecPtr lsn = _lsn;
        RelKey relKey;
        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);


#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &nblocksTime[0], &nblocksCount[0])
#endif

//        uint32_t foundPageNum = 0;
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
//        RelSizePthreadReadLock(relKey);
//        if ( GetRelSizeCache(relKey, &foundPageNum) ) {
//            RelSizePthreadUnlock(relKey);
#ifdef ENABLE_DEBUG_INFO2
            printf("%s cached, pageNum = %u\n", __func__, foundPageNum);
            fflush(stdout);
#endif
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &nblocksTime[1], &nblocksCount[1])
#endif
#ifdef INFO_FUNC_END
//            printf("%s end\n", __func__ );
#endif
//            return (int32_t)foundPageNum;
//        }
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
//        RelSizePthreadUnlock(relKey);

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &nblocksTime[2], &nblocksCount[2])
#endif
        int relSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, 0);
//        bool relExists = smgrexists(smgrReln, (ForkNumber)_forknum);
//        if(relExists == false) {
//            relSize = -1;
//        } else { // If relation exists, get page number
//            relSize = smgrnblocks(smgrReln, (ForkNumber)_forknum);
//        }
#ifdef ENABLE_DEBUG_INFO2
        printf("%s get relsize=%d from standalone pg\n", __func__ , relSize);
        fflush(stdout);
#endif
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
//        RelSizePthreadWriteLock(relKey);
//        uint32 tempResult = 0;
//        if(relSize>=0 && GetRelSizeCache(relKey, &tempResult) == false)
//            InsertRelSizeCache(relKey, (uint32) relSize);
//        RelSizePthreadUnlock(relKey);
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
#ifdef ENABLE_DEBUG_INFO
        if(insertSucc) {
            printf("%s insert key successfully\n", __func__ );
        } else {
            printf("%s insert key failed\n", __func__ );
        }
#endif

//        BlockNumber result = mdnblocks(smgrReln, (ForkNumber)_forknum);
#ifdef ENABLE_DEBUG_INFO
        printf("%s end\n", __func__ );
        fflush(stdout);
#endif

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &nblocksTime[3], &nblocksCount[3])
#endif
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
        return relSize;
    }

    int32_t RpcMdExists(const _Smgr_Relation& _reln, const int32_t _forknum, const int64_t _lsn) {
#ifdef INFO_FUNC_START
        printf("%s start, spc = %lu, db = %lu, rel = %lu, fork = %d, lsn = %lu\n", __func__ , _reln._spc_node, _reln._db_node,
               _reln._rel_node, _forknum, _lsn);
        fflush(stdout);
#endif
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef DEBUG_TIMING
        struct timeval start, end;
        START_TIMING(&start);
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, lsn = %ld tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _lsn, gettid());
        fflush(stdout);
#endif

        WaitParse(_lsn);
#ifdef ENABLE_DEBUG_INFO
        printf("%s pass Parse, spc = %lu, db = %lu, rel = %lu, fork = %d, lsn = %lu\n", __func__ , _reln._spc_node, _reln._db_node,
               _reln._rel_node, _forknum, _lsn);
        fflush(stdout);
#endif
//        SyncReplayProcess();

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

//        RelKey relKey;
//        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);

//        uint32_t foundPageNum;
//        RelSizePthreadReadLock(relKey);
//        int found = GetRelSizeCache(relKey, &foundPageNum);
//        RelSizePthreadUnlock(relKey);
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &existsTime[0], &existsCount[0])
#endif
//        if(found) {
//            printf("%s %d\n", __func__ , __LINE__);
//            fflush(stdout);
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &existsTime[1], &existsCount[1])
#endif
#ifdef INFO_FUNC_END
//            printf("%s end, found from cache, pageNum = %u\n", __func__ , foundPageNum);
#endif
//                return (foundPageNum>0);
//        }
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);

//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
//        int32_t result = mdexists(smgrReln, (ForkNumber)_forknum);

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &existsTime[2], &existsCount[2])
#endif

//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
        int relSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, 0);

//        bool relExists = smgrexists(smgrReln, (ForkNumber)_forknum);
//        if(relExists == false) {
//            relSize = -1;
//        } else { // If relation exists, get page number
//            relSize = smgrnblocks(smgrReln, (ForkNumber) _forknum);
//        }

#ifdef ENABLE_DEBUG_INFO
        printf("%s get relsize=%d from standalone pg\n", __func__ , relSize);
#endif
//        uint32 tempResult = -1;
//        RelSizePthreadWriteLock(relKey);
//        if(relSize >= 0 && GetRelSizeCache(relKey, &tempResult)==false)
//            InsertRelSizeCache(relKey, (uint32)relSize);
//        RelSizePthreadUnlock(relKey);
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
#ifdef ENABLE_DEBUG_INFO
        if(insertSucc) {
            printf("%s insert key successfully\n", __func__ );
        } else {
            printf("%s insert key failed\n", __func__ );
        }
#endif

#ifdef ENABLE_DEBUG_INFO
        printf("%s result = %d end\n", __func__, relSize);
        fflush(stdout);
#endif
#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &existsTime[3], &existsCount[3])
#endif
#ifdef INFO_FUNC_END
        printf("%s end, spc = %lu, db = %lu, rel = %lu, fork = %d, lsn = %lu, result = %d\n", __func__ , _reln._spc_node, _reln._db_node,
               _reln._rel_node, _forknum, _lsn, relSize);
        fflush(stdout);
#endif
        return (relSize>0);
    }

    void RpcMdCreate(const _Smgr_Relation& _reln, const int32_t _forknum, const int32_t _isRedo, const int64_t _lsn) {
#ifdef INFO_FUNC_START
        printf("%s start, spc = %lu, db= %lu, rel = %lu, fork = %d, lsn = %ld\n", __func__ , _reln._spc_node, _reln._db_node,
               _reln._rel_node, _forknum, _lsn);
#endif
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, lsn = %lu tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _lsn, gettid());
        fflush(stdout);
#endif

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

#ifdef PASS
//        SyncReplayProcess();
        WaitParse(_lsn);

        RelKey relKey;
        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);

        uint64_t foundLsn;
        uint32 foundPageNum;
        RelSizePthreadWriteLock(relKey);
        int found = GetRelSizeCache(relKey, &foundPageNum);
        if(!found) {
            InsertRelSizeCache(relKey, 0);
        }
        RelSizePthreadUnlock(relKey);
#endif

//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);

        WalRedoCreateRel(rnode, (ForkNumber)_forknum);
//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
//        mdcreate(smgrReln, (ForkNumber)_forknum, _isRedo);

#ifdef ENABLE_DEBUG_INFO
        printf("%s end\n", __func__);
        fflush(stdout);
#endif
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
    }

    void RpcMdExtend(const _Smgr_Relation& _reln, const int32_t _forknum, const int32_t _blknum, const _Page& _buff, const int32_t skipFsync, const int64_t _lsn) {
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blknum = %d lsn = %ld tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
        fflush(stdout);
#endif

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

#ifdef PASS
//        SyncReplayProcess();
        WaitParse(_lsn);

        RelKey relKey;
        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);

//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
        uint64_t foundLsn;
        uint32_t foundPageNum;
        RelSizePthreadWriteLock(relKey);
        int found = GetRelSizeCache(relKey, &foundPageNum);
        //TODO: Here may have some problems: extend-page content's lsn is larger than parameter lsn
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d\n", __func__ , __LINE__);
        fflush(stdout);
#endif
        if(!found || foundPageNum<_blknum+1) {
            InsertRelSizeCache(relKey, _blknum+1);
        }
        RelSizePthreadUnlock(relKey);
#endif

//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d\n", __func__ , __LINE__);
        fflush(stdout);
#endif
        BufferTag tag;
        INIT_BUFFERTAG(tag, rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);
        char *extendPage = (char*) malloc(BLCKSZ);

        _buff.copy(extendPage, BLCKSZ);
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d, parameter lsn = %lu\n", __func__ , __LINE__, PageGetLSN(extendPage));
        fflush(stdout);
#endif

        //TODO: maybe it not this reason
        /*!
         *  Important: Before we put this extended page to
         */
        // Put version:-1 to RocksDB
//        PutPage2Rocksdb(tag, 1, extendPage);

//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
//        mdextend(smgrReln, (ForkNumber)_forknum, (BlockNumber)_blknum, extendPage, skipFsync);

        WalRedoExtendRel(rnode, (ForkNumber) _forknum, (BlockNumber) _blknum, extendPage);
        free(extendPage);
//        char extendPage[BLCKSZ+16];
//        _buff.copy(extendPage, BLCKSZ);
//
#ifdef ENABLE_DEBUG_INFO
        printf("%s end\n", __func__);
        fflush(stdout);
#endif
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
    }


    void RpcTruncate(const _Smgr_Relation& _reln, const int32_t _forknum, const int32_t _blknum, const int64_t _lsn) {
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blknum = %d lsn = %ld tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
        fflush(stdout);
#endif

        WaitParse(_lsn);

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
//        RelKey relKey;
//        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);
//
//        RelSizePthreadWriteLock(relKey);
//        InsertRelSizeCache(relKey, _blknum);
//        RelSizePthreadUnlock(relKey);

        SMgrRelation sMgrRelation;
        sMgrRelation = smgropen(rnode, InvalidBackendId);
        smgrtruncate(sMgrRelation, (ForkNumber*)&_forknum, 1, (BlockNumber*)&_blknum);
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
    }


    // Following are fd.c interfaces
    void RpcFileClose(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        FileClose(_fd);
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
    }

    void RpcTablespaceCreateDbspace(const _Oid _spcnode, const _Oid _dbnode, const bool isRedo) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        TablespaceCreateDbspace(_spcnode, _dbnode, isRedo);
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
    }

    _File RpcPathNameOpenFile(const _Path& _path, const _Flag _flag) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start, filename = %s\n", __func__, _path.c_str() );
#endif
        _File result =  PathNameOpenFile(_path.c_str(), _flag);
//        printf("[%s] result = %d\n", __func__ , result);
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
        return result;
    }

    // todo
    int32_t RpcFileWrite(const _File _fd, const _Page& _page, const int32_t _amount, const _Off_t _seekpos, const int32_t _wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        // Your implementation goes here
        char buff[BLCKSZ+8];
        _page.copy(buff, BLCKSZ);
        return FileWrite(_fd, buff, _amount, _seekpos, _wait_event_info);

//        int writeLen = 0;
//        char * page = (char *) malloc(BLCKSZ);
//        _page.copy(page, BLCKSZ);
//
//        RpcRelation relNode = ParseRpcRequestPath(FilePathName(_fd), _seekpos);
//        if (relNode.parseSucc) {
//            writeLen = RpcFileWriteWithCache(_fd, page, relNode, _seekpos);
//        } else {
        //We arrived here only when some rare cases occur, for example, have backendID etc.
//            writeLen = FileWrite(_fd, page, _amount, _seekpos, _wait_event_info);
//        }
//
//        free(page);
//        return writeLen;
    }

    void RpcFilePathName(_Path& _return, const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        char * filename = FilePathName(_fd);
        _return.assign(filename);
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
        return;
    }

    // todo
    void RpcFileRead(_Page& _return, const _File _fd, const int32_t _amount, const _Off_t _seekpos, const int32_t _wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        char *page = (char *)malloc(BLCKSZ);
        int readLen = 0;

//        RpcRelation relNode = ParseRpcRequestPath(FilePathName(_fd), _seekpos);
//        printf("[%s]parse succ=%d, spc = %d, db = %d, rel = %d, fork = %d, block = %d\n",
//               __func__, relNode.parseSucc, relNode.spcNode, relNode.dbNode, relNode.relNode, relNode.forkNum, relNode.blockNum);
//        if (relNode.parseSucc) {
//            readLen = RpcFileReadWithCache(_fd, page, relNode, _seekpos);
//        } else {
        // We arrived here only when some rare cases occur, for example, have backendID etc.
        readLen = FileRead(_fd, page, _amount, _seekpos, _wait_event_info);
//        }

        _return.assign(page, readLen);
        free(page);
        return;
    }

    // todo
    int32_t RpcFileTruncate(const _File _fd, const _Off_t _offset) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s :start\n", __func__ );
#endif
        return FileTruncate(_fd, _offset, WAIT_EVENT_DATA_FILE_TRUNCATE);
    }

    _Off_t RpcFileSize(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start, fd = %d, tid = %d\n", __func__ , _fd, gettid());
#endif
        _Off_t result = FileSize(_fd);
#ifdef INFO_FUNC_END
        printf("%s end, tid = %d, fd = %d, result = %d\n", __func__ , gettid(), _fd, result);
#endif
        return result;
    }

    int32_t RpcFilePrefetch(const _File _fd, const _Off_t _offset, const int32_t _amount, const int32_t wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return FilePrefetch(_fd, _offset, _amount, wait_event_info);
    }

    void RpcFileWriteback(const _File _fd, const _Off_t _offset, const _Off_t nbytes, const int32_t wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        FileWriteback(_fd, _offset, nbytes, wait_event_info);
        return;
    }

    int32_t RpcUnlink(const _Path& _path) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return unlink(_path.c_str());
    }

    int32_t RpcFtruncate(const _File _fd, const _Off_t _offset) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return ftruncate(_fd, _offset);
    }

    void RpcInitFile(_Page& _return, const _Path& _path) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
    }

    _File RpcOpenTransientFile(const _Path& _filename, const int32_t _fileflags) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return OpenTransientFile(_filename.c_str(), _fileflags);
    }

    int32_t RpcCloseTransientFile(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return CloseTransientFile(_fd);
    }

    void Rpcread(_Page& _return, const _File _fd, const int32_t size) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
    }

    int32_t Rpcwrite(const _File _fd, const _Page& _page, const int32_t size) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
    }

    int32_t RpcFileSync(const _File _fd, const int32_t _wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return FileSync(_fd, _wait_event_info);
    }

    void RpcPgPRead(_Page& _return, const _File _fd, const int32_t _seg_bytes, const _Off_t _start_off) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        char *p = (char*)malloc(_seg_bytes+64);
         if(_start_off == -1) {
             read(_fd, p, _seg_bytes);
         } else {
             pg_pread(_fd, p, _seg_bytes, _start_off);
         }
        _return.assign(p, _seg_bytes);
        free(p);
        return;
    }

    int32_t RpcPgPWrite(const _File _fd, const _Page& _page, const int32_t _amount, const _Off_t _offset) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
         int32_t result;
         if(_offset == -1) {
             result = write(_fd, _page.c_str(), _amount);
         } else {
             result = pg_pwrite(_fd, _page.c_str(), _amount, _offset);
         }
//        printf("RpcPgPWrite, result = %d\n", result);
        return result;
    }

    int32_t RpcClose(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return close(_fd);
    }

    int32_t RpcBasicOpenFile(const _Path& _path, const int32_t _flags) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
        int32_t result = BasicOpenFile(_path.c_str(), _flags);
#ifdef INFO_FUNC_START
        printf("%s start, fileName = %s, result = %d\n", __func__ , _path.c_str(), result);
        fflush(stdout);
#endif
        return result;
    }

    int32_t RpcPgFdatasync(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return pg_fdatasync(_fd);
    }

    int32_t RpcPgFsyncNoWritethrough(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return pg_fsync_no_writethrough(_fd);
    }

    int32_t RpcLseek(const int32_t _fd, const _Off_t _offset, const int32_t _flag) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return lseek(_fd, _offset, _flag);
    }

    void RpcStat(_Stat_Resp& _return, const _Path& _path) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        struct stat result;
        _return._result = stat(_path.c_str(), &result);
        _return._stat_mode = result.st_mode;
        return;
    }

    int32_t RpcDirectoryIsEmpty(const _Path& _path) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return directory_is_empty(_path.c_str());
    }

    int32_t RpcCopyDir(const _Path& _src, const _Path& _dst) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        char* src = (char*) malloc(1024);
        char* dst = (char*) malloc(1024);
//        printf("_src = %s, dst = %s\n", _src.c_str(), _dst.c_str());
        _src.copy(src, _src.length());
        _dst.copy(dst, _dst.length());
        src[_src.length()] = 0;
        dst[_dst.length()] = 0;
//        printf("src = %s, dst = %s\n", src, dst);
        copydir(src, dst, false);
        free(src);
        free(dst);
        return 0;
    }

    int32_t RpcPgFsync(const int32_t _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        int32_t result = pg_fsync(_fd);
//        printf("RpcPgFsync, result = %d\n", result);
        return result;
    }

    int32_t RpcDurableUnlink(const _Path& _fname, const int32_t _flag) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return durable_unlink(_fname.c_str(), _flag);
    }

    int32_t RpcDurableRenameExcl(const _Path& _oldFname, const _Path& _newFname, const int32_t _elevel) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start, oldName = %s, newName = %s\n", __func__ , _oldFname.c_str(), _newFname.c_str());
        fflush(stdout);
#endif
        int32_t result =  durable_rename_excl(_oldFname.c_str(), _newFname.c_str(), _elevel);
#ifdef INFO_FUNC_START
        printf("%s end\n", __func__ );
        fflush(stdout);
#endif

        return result;
    }

    int32_t RpcXLogWrite(const _File _fd, const _Page& _page, const int32_t _amount, const _Off_t _offset, const std::vector<int64_t> & _xlblocks, const int32_t _blknum, const int32_t _idx, const int64_t _lsn) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        // Your implementation goes here
#ifdef INFO_FUNC_START2
        printf("%s %d, blockNum = %d, start_idx = %d, lsn = %ld\n", __func__ , __LINE__, _blknum, _idx, _lsn);
        for(int i = 0; i < _blknum; i++){
            printf("_xlblocks[%d] = %ld\n", i, _xlblocks[i]);
        }
        fflush(stdout);
        printf("%s %d, start lsn = %lu, end lsn = %ld\n", __func__ , __LINE__, _lsn, _xlblocks[_blknum-1]);
        fflush(stdout);
#endif


        int32_t result = pg_pwrite(_fd, _page.c_str(), _amount, _offset);
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d, fd = %d, result = %d\n", __func__ , __LINE__, _fd, result);
        fflush(stdout);
#endif

        // Need some lock
//        for(int i = 0; i < _blknum; i++) {
//            pthread_rwlock_wrlock(&(RpcXLogPagesLocks[(_idx+i)]));
//            RpcXlblocks[(_idx+i)%XLOGbuffers] = _xlblocks[i];
//        }

        // Based on XLogWrite code, startIdx+_blknum <= XLogBuffers-1
        // So, RpcXLogPages + (_idx*BLCKSZ) + (_blknum*BLCKSZ) will smaller than or equal with end of RpcXLogPages
//        memcpy( RpcXLogPages+(XLOG_BLCKSZ*_idx), _page.c_str(), XLOG_BLCKSZ*_blknum );

//        for(int i = 0; i < _blknum; i++) {
//            pthread_rwlock_unlock(&(RpcXLogPagesLocks[(_idx+i)]));
//        }

        if(RpcXLogFlushedLsn < _lsn) {
            RpcXLogFlushedLsn = (uint64_t) _lsn;
        }

        SetWalRcvFlushedUpto(_lsn);

//        pthread_mutex_lock(&wakeupMutex);
        WakeupRecovery();
//        WakeupStartupRecovery();
//        pthread_mutex_unlock(&wakeupMutex);

        // sigusr1_handler(SIGNAL_ARGS) -> should send signal to RpcServer
        // how to set flushUpto? set it with _blknum-1 pages? Or XLogWrite also send XLogWriteResult.lsn to this function.

        return result;
    }

    void RpcXLogFileInit(_XLog_Init_File_Resp& _return, const int64_t _logsegno, const int32_t _use_existent, const int32_t _use_lock) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
//        printf("%s start\n", __func__ );
//        fflush(stdout);

        bool use_existent = (_use_existent == 1);
        bool use_lock = (_use_lock == 1);

        int fd = XLogFileInit(_logsegno, &use_existent, use_lock);
#ifdef INFO_FUNC_START
        printf("%s start, logsegno = %ld, fd = %d\n", __func__ , _logsegno, fd);
        fflush(stdout);
#endif

        _return._fd = fd;
        _return._use_existent = use_existent;

    }


    /**
     * This method has a oneway modifier. That means the client only makes
     * a request and does not listen for any response at all. Oneway methods
     * must be void.
     */
    void zip() {
        // Your implementation goes here
        printf("zip\n");
    }

};


void
RpcServerLoop(void){
    int port = 9090;

    std::shared_ptr<concurrency::ThreadFactory> threadFactory = std::make_shared<concurrency::ThreadFactory>(new concurrency::ThreadFactory());
//    std::shared_ptr<concurrency::ThreadManager> threadManager = concurrency::ThreadManager::newThreadManager();
    std::shared_ptr<concurrency::ThreadManager> threadManager = concurrency::ThreadManager::newSimpleThreadManager(150);
    threadManager->threadFactory(threadFactory);
    threadManager->start();


//    TSimpleServer server(
//    TThreadedServer server(
    std::shared_ptr<server::TServer> server;
    server.reset ( new TThreadPoolServer(
            std::make_shared<DataPageAccessProcessor>(std::make_shared<DataPageAccessHandler>()),
            std::make_shared<TServerSocket>(port), //port
            std::make_shared<TBufferedTransportFactory>(),
            std::make_shared<TBinaryProtocolFactory>(),
            threadManager
            ) );

    concurrency::ThreadFactory factory;
    factory.setDetached(false);
    std::shared_ptr<apache::thrift::concurrency::Runnable> serverThreadRunner(server);
    std::shared_ptr<apache::thrift::concurrency::Thread> thread = factory.newThread(serverThreadRunner);
    thread->start();
    concurrency::Monitor gMonitor;
    gMonitor.waitForever();

    server->stop();
    thread->join();
    server.reset();
}
