// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "c.h"
#include "postgres.h"
#include <cstring>


#include "DataPageAccess.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include "storage/fd.h"
#include "commands/tablespace.h"
#include "storage/rpcserver.h"
#include "storage/bufmgr.h"
#include <sys/stat.h>
#include "storage/copydir.h"
#include "storage/md.h"
#include "catalog/catalog.h"
#include "utils/relcache.h"
#include "storage/smgr.h"
#include "utils/rel.h"
#include "tcop/storage_server.h"
#include "access/logindex_hashmap.h"
#include "access/wakeup_latch.h"
#include "replication/walreceiver.h"
#include "storage/kv_interface.h"
#include "storage/buf_internals.h"
#include "access/xlog.h"
#include "pgstat.h"
#include "storage/rel_cache.h"

extern HashMap pageVersionHashMap;

extern int reachXlogTempEnd;
extern int XLOGbuffers;

extern XLogRecPtr *RpcXlblocks;
extern char* RpcXLogPages;
extern pthread_rwlock_t *RpcXLogPagesLocks;

extern uint64_t RpcXLogFlushedLsn;


//#define DEBUG_TIMING 1
//#define INFO_FUNC_START
//#define INFO_FUNC_START2
//#define ENABLE_DEBUG_INFO
//#define ENABLE_DEBUG_INFO2

//#define ENABLE_FUNCTION_TIMING

#ifdef ENABLE_FUNCTION_TIMING
#include <sys/time.h>
#include <pthread.h>
#include <cstdlib>

class FunctionTiming {
public:
    struct timeval start;
    struct timeval reTiming;
    char* funcname;
    FunctionTiming(char* paraFuncName) {
        funcname = paraFuncName;
        gettimeofday(&start, NULL);
        gettimeofday(&reTiming, NULL);
    }

    void RecordTime(int lineNum) {
        struct timeval tempTiming;
        gettimeofday(&tempTiming, NULL);
        printf("%s%d function timeing = %ld us\n", funcname, lineNum,
               (tempTiming.tv_sec*1000000+tempTiming.tv_usec) - (reTiming.tv_sec*1000000+reTiming.tv_usec));
        fflush(stdout);

        gettimeofday(&reTiming, NULL);
    }

    inline ~FunctionTiming() {
        struct timeval end;
        gettimeofday(&end, NULL);
        printf("%s function timeing = %ld us\n", funcname,
               (end.tv_sec*1000000+end.tv_usec) - (start.tv_sec*1000000+start.tv_usec));
        fflush(stdout);
    }
};
#endif

#ifdef DEBUG_TIMING

#include <sys/time.h>
#include <pthread.h>
#include <cstdlib>

int initialized = 0;
struct timeval output_timing;

pthread_mutex_t timing_mutex = PTHREAD_MUTEX_INITIALIZER;
long readBufferCommon[36];
long readBufferCount[36];

long nblocksTime[16];
long nblocksCount[16];

long existsTime[16];
long existsCount[16];

void PrintTimingResult() {
    struct timeval now;

    if(!initialized){
        gettimeofday(&output_timing, NULL);
        initialized = 1;

        memset(readBufferCount, 0, 16*sizeof(readBufferCount[0]));
        memset(readBufferCommon, 0, 16*sizeof(readBufferCommon[0]));

        memset(nblocksCount, 0, 16*sizeof(nblocksCount[0]));
        memset(nblocksTime, 0, 16*sizeof(nblocksTime[0]));

        memset(existsCount, 0, 16*sizeof(existsCount[0]));
        memset(existsTime, 0, 16*sizeof(existsTime[0]));
    }


    gettimeofday(&now, NULL);

    if(now.tv_sec-output_timing.tv_sec >= 1) {
        for(int i = 0 ; i < 35; i++) {
            if(readBufferCount[i] == 0)
                continue;
            printf("readBufferCommon_%d = %ld\n",i,  readBufferCommon[i]/readBufferCount[i]);
            printf("total_readBufferCommon_%d = %ld, count = %ld\n",i,  readBufferCommon[i], readBufferCount[i]);
            fflush(stdout);
        }

        for(int i = 0 ; i < 9; i++) {
            if(nblocksCount[i] == 0)
                continue;
            printf("nblocks_%d = %ld\n",i,  nblocksTime[i]/nblocksCount[i]);
            printf("nblocks_%d = %ld, count = %ld\n",i,  nblocksTime[i], nblocksCount[i]);
            fflush(stdout);
        }

        for(int i = 0 ; i < 9; i++) {
            if(existsCount[i] == 0)
                continue;
            printf("exists_%d = %ld\n",i,  existsTime[i]/existsCount[i]);
            printf("exists_%d = %ld, count = %ld\n",i,  existsTime[i], existsCount[i]);
            fflush(stdout);
        }

        output_timing = now;
    }
}

#define START_TIMING(start_p)  \
do {                         \
    gettimeofday(start_p, NULL); \
} while(0);

#define RECORD_TIMING(start_p, end_p, global_timing, global_count) \
do { \
    gettimeofday(end_p, NULL); \
    pthread_mutex_lock(&timing_mutex); \
    (*global_timing) += ((*end_p.tv_sec*1000000+*end_p.tv_usec) - (*start_p.tv_sec*1000000+*start_p.tv_usec))/1000; \
    (*global_count)++;                                                               \
    pthread_mutex_unlock(&timing_mutex); \
    PrintTimingResult(); \
    gettimeofday(start_p, NULL); \
} while (0);


#endif

extern XLogRecPtr XLogParseUpto;

static void TransRelNode2RelKey(RelFileNode node, RelKey *relKey, ForkNumber forkNumber) {
    relKey->SpcId = node.spcNode;
    relKey->DbId = node.dbNode;
    relKey->RelId = node.relNode;

    relKey->forkNum = forkNumber;
    return;
}
#include <sys/time.h>

pthread_mutex_t wakeupMutex;
void WaitParse(int64_t _lsn) {

//    struct timeval now;
//    gettimeofday(&now, NULL);
//    printf("parameter_lsn = %lu, second = %lu, us = %lu\n",
//           _lsn, now.tv_sec, now.tv_usec);
//    fflush(stdout);

//    if(WalRcvRunning() == false)
//        return;
//    XLogRecPtr flushUpto = WalRcv->flushedUpto;
//    if((XLogRecPtr)_lsn > XLogParseUpto && XLogParseUpto < flushUpto && XLogParseUpto != 0) {
    if((XLogRecPtr)_lsn > XLogParseUpto && XLogParseUpto < RpcXLogFlushedLsn && XLogParseUpto != 0) {
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
               __func__ , __LINE__, _lsn, XLogParseUpto, RpcXLogFlushedLsn);
        fflush(stdout);
#endif
        XLogRecPtr targetLsn = RpcXLogFlushedLsn;
        if(_lsn < targetLsn)
            targetLsn = _lsn;

        XLogRecPtr prevParse = XLogParseUpto;

        int count = 0;
        XLogRecPtr tempRecord = 0;
        while(XLogParseUpto < targetLsn-64 && !reachXlogTempEnd ) {
            if (XLogParseUpto != tempRecord) {
//                if(count >= 50) {
//                    printf("%s %d, clog lsn = %lu, target lsn = %lu, count = %d\n", __func__ ,
//                           __LINE__, XLogParseUpto, targetLsn, count);
//                    fflush(stdout);
//                }
                tempRecord = XLogParseUpto;
                count = 0;
            } else {
                count ++;
            }

//            if(count == 4) {
//                XLogParseUpto = targetLsn;
//            }
//            printf("%s %d keep waiting , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
//                   __func__ , __LINE__, _lsn, XLogParseUpto, flushUpto);
//            fflush(stdout);
#ifdef ENABLE_DEBUG_INFO
            count++;
            if(count % 10 == 0) {
                printf("%s %d keep waiting , parameter_lsn = %lu, ParseUpto = %lu, flushUpto = %lu\n",
                       __func__ , __LINE__, _lsn, XLogParseUpto, RpcXLogFlushedLsn);
                fflush(stdout);
                count = 0;
            }
#endif

//            printf("%s get into sleep\n", __func__ );
//            fflush(stdout);
            usleep(500);
//            pthread_mutex_lock(&wakeupMutex);
//            WakeupRecovery();
//            WakeupStartupRecovery();
//            pthread_mutex_unlock(&wakeupMutex);
//            if(reachXlogTempEnd && XLogParseUpto != prevParse) {
//                reachXlogTempEnd = 0;
//            }
//            if(reachXlogTempEnd) {
//                waitCount++;
//            }
        }

        if(reachXlogTempEnd) {
            reachXlogTempEnd = 0;
        }
    }
//    printf("%s %d exit\n" ,__func__ , __LINE__);
//    fflush(stdout);
}

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::tutorial;
class DataPageAccessHandler : virtual public DataPageAccessIf {
public:
    DataPageAccessHandler() {
        // Your initialization goes here
    }

    /**
     * A method definition looks like C code. It has a return type, arguments,
     * and optionally a list of exceptions that it may throw. Note that argument
     * lists and exception lists are specified using the exact same syntax as
     * field lists in struct or exception definitions.
     *
     * @param _fd
     */

    void
    ReadBufferCommon(_Page &_return, const _Smgr_Relation &_reln, const int32_t _relpersistence, const int32_t _forknum,
                     const int32_t _blknum, const int32_t _readBufferMode, const int64_t _lsn) {

//        printf("%s %d start, spc = %lu, db = %lu, rel = %lu, fork = %d, blk = %d, lsn = %lu, tid = %d\n", __func__ , __LINE__,
//               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
//        fflush(stdout);

        WaitParse(_lsn);

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

        KeyType key;
        key.SpcID = _reln._spc_node;
        key.DbID = _reln._db_node;
        key.RelID = _reln._rel_node;
        key.ForkNum = _forknum;
        key.BlkNum = _blknum;

        uint64_t replayedLsn;
        uint64_t *toReplayList;
        int listSize = 0;
        int found = HashMapGetBlockReplayList(pageVersionHashMap, key, _lsn, &replayedLsn, &toReplayList, &listSize);


        if (!found) {

            BufferTag bufferTag;
            INIT_BUFFERTAG(bufferTag, rnode, (ForkNumber) _forknum, (BlockNumber) _blknum);
            char *buff = (char *) malloc(BLCKSZ);
            GetBasePage(rnode, (ForkNumber) _forknum, (BlockNumber) _blknum, buff);

            _return.assign(buff, BLCKSZ);

//            HashMapInsertKey(pageVersionHashMap, key, 1, -1, true);
//            HashMapUpdateReplayedLsn(pageVersionHashMap, key, 1, false);
//            PutPage2Rocksdb(bufferTag, 1, buff);
            free(buff);

//            printf("%s %d, spc = %lu, db = %lu, rel = %lu, fork = %d, blk = %d, lsn = %lu, tid = %d\n", __func__ , __LINE__,
//                   _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
//            fflush(stdout);

            return;
        }

        // Then replayLSN is what we needed from RocksDB
        if (listSize == 0) {
            char* targetPage = NULL;

            BufferTag bufferTag;
            INIT_BUFFERTAG(bufferTag, rnode, (ForkNumber) _forknum, (BlockNumber) _blknum);
            GetPageFromRocksdb(bufferTag, replayedLsn, &targetPage);

            _return.assign(targetPage, BLCKSZ);
            free(targetPage);
//            printf("%s %d, spc = %lu, db = %lu, rel = %lu, fork = %d, blk = %d, lsn = %lu, tid = %d\n", __func__ , __LINE__,
//                   _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
//            fflush(stdout);
            return;
        }



        // For now, we need to replay several xlogs until we get the expected version
        // The xlog sublist we need to replay is [ uintList[1]+2 , foundPos ]

        char *page2 = (char *) malloc(BLCKSZ);

        //! Print all the lsn in the list
//        printf("%s %d, tid = %d, listsize = %d, replayedLSN = %lu\n", __func__ , __LINE__, gettid(), listSize, replayedLsn);
//        fflush(stdout);
//        for(int i = 0; i < listSize; i++) {
//            printf("%lu , tid = %d\n", toReplayList[i], gettid());
//            fflush(stdout);
//        }

        BufferTag bufferTag;
        INIT_BUFFERTAG(bufferTag, rnode, (ForkNumber) _forknum, (BlockNumber) _blknum);

        if(replayedLsn > 0) {
            char* basePage = NULL;
            GetPageFromRocksdb(bufferTag, replayedLsn, &basePage);
            ApplyLsnList(rnode, (ForkNumber) _forknum, (BlockNumber) _blknum, reinterpret_cast<XLogRecPtr *>(toReplayList),
                         listSize, basePage, page2);
            free(basePage);
        } else {
            ApplyLsnListAndGetUpdatedPage(rnode, (ForkNumber) _forknum, (BlockNumber) _blknum, reinterpret_cast<XLogRecPtr *>(toReplayList),
                                          listSize, page2);
        }


        PutPage2Rocksdb(bufferTag, toReplayList[listSize - 1], page2);


        if (listSize > 0) {
            HashMapUpdateReplayedLsn(pageVersionHashMap, key, toReplayList[listSize - 1], true);

            free(toReplayList);
#ifdef ENABLE_FUNCTION_TIMING
            functionTiming.RecordTime(__LINE__);
#endif
        }

        if(replayedLsn && listSize>0) {
            DeletePageFromRocksdb(bufferTag, replayedLsn);
        }

//        printf("%s %d end, targetPageLsn = %lu, spc = %lu, db = %lu, rel = %lu, fork = %d, blk = %d, lsn = %lu, tid = %d\n", __func__ , __LINE__,
//               PageGetLSN(page2), _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
//        fflush(stdout);

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &readBufferCommon[14], &readBufferCount[14])
#endif

        //TODO: Return page2
        // Set the desired page version as return value
        _return.assign(page2, BLCKSZ);

        free(page2);

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &readBufferCommon[15], &readBufferCount[15])
#endif

    }


    void ReadBufferCommon_ignore(_Page& _return, const _Smgr_Relation& _reln, const int32_t _relpersistence, const int32_t _forknum, const int32_t _blknum, const int32_t _readBufferMode, const int64_t _lsn) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blkNum = %d, lsn = %ld\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn);
        fflush(stdout);
#endif

#ifdef DEBUG_TIMING
        struct timeval start, end;
        START_TIMING(&start);
#endif

        WaitParse(_lsn);


#ifdef ENABLE_FUNCTION_TIMING
        functionTiming.RecordTime(__LINE__);
#endif
        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;
//
//        uint64_t *uintList;
//        int listSize;
//        BufferTag tag;
//        INIT_BUFFERTAG(tag, rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);

        // Get relation size from in-memory hashmap
        // If relation size is smaller than parameter request $_blknum, just return blank page (caused by RpcMdCreate, RpcMdExist)
        /**********************************START IN MEMORY REL SIZE CACHE***************************************/
//        char* blankPage = (char*) malloc(BLCKSZ);
//        MemSet(blankPage, 0, BLCKSZ);
//        struct KeyType key{};
//        key.SpcID = rnode.spcNode;
//        key.DbID = rnode.dbNode;
//        key.RelID = rnode.relNode;
//        key.ForkNum = _forknum;
//
//        uint64_t foundLsnInMemory;
//        int foundPageNumInMemory;
//        int foundInMemory = HashMapFindLowerBoundEntry(key, WalRcv->flushedUpto, &foundLsnInMemory, &foundPageNumInMemory);
//        // If relation size not cached, read from standalone process
//        if(!foundInMemory) {
//            int relSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, 0);
//            printf("%s get relsize=%d from standalone pg\n", __func__ , relSize);
//            bool insertSucc = HashMapInsertKey(key, WalRcv->flushedUpto, relSize);
//            if(insertSucc) {
//                printf("%s insert key successfully\n", __func__ );
//            } else {
//                printf("%s insert key failed\n", __func__ );
//            }
//            // If existing relation is smaller than parameter, just return zero pages
//            if(relSize < _blknum+1) {
//                free(blankPage);
//                _return.assign(blankPage, BLCKSZ);
//                return;
//            }
//        } else { // Get relation size from cache
//            printf("%s get cached relsize=%d\n", __func__ , foundPageNumInMemory);
//            fflush(stdout);
//            if(foundPageNumInMemory < _blknum+1) {
//                free(blankPage);
//                _return.assign(blankPage, BLCKSZ);
//                return;
//            }
//        }
//         free(blankPage);
        /************************************END IN MEMORY REL SIZE CACHE***************************************/

        KeyType key;
        key.SpcID = _reln._spc_node;
        key.DbID = _reln._db_node;
        key.RelID = _reln._rel_node;
        key.ForkNum = _forknum;
        key.BlkNum = _blknum;

        uint64_t  replayedLsn;
        uint64_t *toReplayList;
        int listSize = 0;
        int found = HashMapGetBlockReplayList(pageVersionHashMap, key, _lsn, &replayedLsn, &toReplayList, &listSize);
//        int found = GetListFromRocksdb(tag, &uintList, &listSize);
#ifdef ENABLE_FUNCTION_TIMING
        functionTiming.RecordTime(__LINE__);
#endif

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &(readBufferCommon[0]), &(readBufferCount[0]))
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s found = %d, listSize = %d, XLogParseUpto = %lu\n", __func__ , found, listSize, XLogParseUpto);
        fflush(stdout);
#endif


        // If not found list, get the base page from standalone process
        if(!found) {

            BufferTag bufferTag;
            INIT_BUFFERTAG(bufferTag,rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);

#ifdef ENABLE_DEBUG_INFO
            printf("%s %d\n", __func__ , __LINE__);
            fflush(stdout);
#endif

            char* buff;
            bool gotPageFromStandAlone = false;
            // Try to get RpcMdExtend page as BasePage
            int foundPage = GetPageFromRocksdb(bufferTag, 1, &buff);
#ifdef ENABLE_FUNCTION_TIMING
            functionTiming.RecordTime(__LINE__);
#endif
            if(foundPage == 0) {
#ifdef ENABLE_DEBUG_INFO
                printf("%s %d, can't find page in RocksDB-extend, try to find it from standalone\n", __func__ , __LINE__);
                fflush(stdout);
#endif
                // If not created by RpcMdExtend, get page from StandAlone process
                gotPageFromStandAlone = true;
                buff = (char*) malloc(BLCKSZ);
                GetBasePage(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, buff);
#ifdef ENABLE_FUNCTION_TIMING
                functionTiming.RecordTime(__LINE__);
#endif
            }
#ifdef ENABLE_FUNCTION_TIMING
            functionTiming.RecordTime(__LINE__);
#endif
#ifdef ENABLE_DEBUG_INFO
            printf("%s %d \n", __func__ , __LINE__);
            fflush(stdout);
#endif
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &(readBufferCommon[1]), &(readBufferCount[1]))
#endif
            XLogRecPtr lsn = PageGetLSN(buff);
#ifdef ENABLE_DEBUG_INFO
            printf("%s %d, get basePage version, lsn = %lu\n", __func__ , __LINE__, lsn);
            fflush(stdout);
#endif


            // (map, key, lsn, pageNum, noEnptySlot); // for pageVersionHashMap, pageNum should always be -1
            HashMapInsertKey(pageVersionHashMap, key, 1, -1, 1);
            HashMapUpdateReplayedLsn(pageVersionHashMap, key, 1, false);

#ifdef ENABLE_FUNCTION_TIMING
            functionTiming.RecordTime(__LINE__);
#endif
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &(readBufferCommon[2]), &(readBufferCount[2]))
#endif
            if(gotPageFromStandAlone) {
                // Remove extended page from Rocksdb
                DeletePageFromRocksdb(bufferTag, 1);
#ifdef DEBUG_TIMING
                RECORD_TIMING(&start, &end, &(readBufferCommon[3]), &(readBufferCount[3]))
#endif
                // Put base page to Rocksdb
                PutPage2Rocksdb(bufferTag, 1, buff);
#ifdef ENABLE_FUNCTION_TIMING
                functionTiming.RecordTime(__LINE__);
#endif
            }

#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &(readBufferCommon[4]), &(readBufferCount[4]))
#endif
            // Set return value from RPC client
            _return.assign(buff, BLCKSZ);

            free(buff);
#ifdef ENABLE_DEBUG_INFO
            printf("%s %d\n", __func__ , __LINE__);
            fflush(stdout);
#endif
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &(readBufferCommon[5]), &(readBufferCount[5]))
#endif
            return;
        }
#ifdef ENABLE_DEBUG_INFO
         printf("%s %d, replayedLsn = %lu\n", __func__ , __LINE__, replayedLsn);
         fflush(stdout);
#endif

         // Now we found the target lsn list

        // If the lsn list $currPos is zero (no xlog was replayed)
        // Then this list was created by replay process, which won't consist base page's lsn.
        // So, we need to get base page from standalone process and insert it lsn as
        // the first element of the list. Also, update $currPos to 1 (base page "replayed")

        char* basePage = (char*) malloc(BLCKSZ);
        bool gotBasePageFromRocksDb = false;
        BufferTag bufferTag;
        INIT_BUFFERTAG(bufferTag,rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);
        if(replayedLsn == 0) {
            //TODO
//            if(GetPageFromRocksdb(bufferTag, 0, &buff) == 0) {
//                printf("%s %d, can't find page in RocksDB-extend, try to find it from standalone\n", __func__ , __LINE__);
//                fflush(stdout);
//                // If not created by RpcMdExtend, get page from StandAlone process
//                buff = (char*) malloc(BLCKSZ);
//                GetBasePage(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, buff);
//            }
            // TODO
            // It's possible that this base page doesn't exist in disk
            // We need to redo at least one lsn
            // Use Exist at first (memory and standalone), if not exist, replay one xlog
            int currRelSize = 0;
            uint32 uintCurrRelSize;
            RelKey relKey;
            TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);
            RelSizePthreadReadLock(relKey);
            bool foundPageSize =  GetRelSizeCache(relKey, &uintCurrRelSize);
            RelSizePthreadUnlock(relKey);
#ifdef ENABLE_FUNCTION_TIMING
            functionTiming.RecordTime(__LINE__);
#endif
            if(!foundPageSize)
                currRelSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, 0);
            else
                currRelSize = int(uintCurrRelSize);

#ifdef ENABLE_FUNCTION_TIMING
            functionTiming.RecordTime(__LINE__);
#endif

            // TODO we should check whether the currRelSize is larger than current _blknum
            if(currRelSize == -1 && listSize != 0) { // we don't have base page in disk, should redo at least one lsn
//                if(listSize == 0) {
//                    printf("Error: %s %d, can't get basePage and any lsn\n", __func__ , __LINE__);
//                    fflush(stdout);
//                }
                ApplyOneLsnWithoutBasePage(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum,
                                           toReplayList[0], basePage);
#ifdef ENABLE_FUNCTION_TIMING
                functionTiming.RecordTime(__LINE__);
#endif
            } else if (currRelSize == -1 && listSize >= 0) { //TODO: listSize>=0 or listSize==0
                /*
                 * For some forknum != 0 relation, the RpcMdExtend will transfer a page with inner lsn equals to 0
                 * And there won't have corresponding xlog generated with this mdextend operation. Therefore, in the prior
                 * process, it is possible that this lsn list is created by RpcMdExtend, and insert the initial lsn=0
                 * (For forknum = 0 relation, extended pages inner lsn won't be zero), and in this function, we found the replayed
                 * lsn is 0, there are two possible reasons: 1. It was created by StartupXLOG, and mark first lsn as 0 to indicate we need
                 * extract base page lsn when replaying it. 2. RpcMdExtend insert initial lsn = 0 for forknum!=0 relations.
                 *
                 * If this list is created by Startup and replayedLsn = 0, then the replayed list len should larger than 0.
                 * So, when we reached here, it's the basePage created by RpcMdExtend, and it's forknum should not be 0.
                 * We should just get this page from RocksDB with lsn = 0.
                 */
                free(basePage);
                gotBasePageFromRocksDb = true;
                int foundBasePage = GetPageFromRocksdb(bufferTag, 1, &basePage);
                if(!foundBasePage) {
                    printf("%s %d, Error: can't find basePage in disk or rocksdb, and there is no lsn to replay\n", __func__ , __LINE__);
                    //fflush(stdout);
                }
#ifdef ENABLE_FUNCTION_TIMING
                functionTiming.RecordTime(__LINE__);
#endif
            }
            else {
                GetBasePage(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, basePage);
#ifdef ENABLE_FUNCTION_TIMING
                functionTiming.RecordTime(__LINE__);
#endif
            }
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &readBufferCommon[6], &readBufferCount[6])
#endif
#ifdef ENABLE_DEBUG_INFO
            printf("%s %d\n", __func__ , __LINE__);
            fflush(stdout);
#endif

//            XLogRecPtr lsn = PageGetLSN(buff);


#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &readBufferCommon[7], &readBufferCount[7])
#endif
            // Set first slot's lsn as this page's lsn
            // Set replayed slot
            HashMapUpdateFirstEmptySlot(pageVersionHashMap, key, 1);

#ifdef ENABLE_FUNCTION_TIMING
            functionTiming.RecordTime(__LINE__);
#endif
#ifdef ENABLE_DEBUG_INFO
            printf("%s LINE=%d \n", __func__ , __LINE__);
            fflush(stdout);
#endif

#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &readBufferCommon[8], &readBufferCount[8])
#endif
        }

        // if replayedLsn == 0, then we have already got basePage from previous section
        if(replayedLsn != 0) {
            gotBasePageFromRocksDb = true;
            free(basePage);

            int foundBasePage = GetPageFromRocksdb(bufferTag, replayedLsn, &basePage);
            if(!foundBasePage) {
                printf("%s %d, Error: can't find basePage in disk or rocksdb, and there is no lsn to replay\n", __func__ , __LINE__);
                //fflush(stdout);
            }
#ifdef ENABLE_FUNCTION_TIMING
            functionTiming.RecordTime(__LINE__);
#endif

        }
#ifdef ENABLE_DEBUG_INFO
         printf("%s LINE=%d, listSize = %d, replayedLsn = %lu \n", __func__ , __LINE__, listSize, replayedLsn);
         fflush(stdout);
#endif


        // For now, we got the lsn list and at least one version was replayed
        // No need to replay the xlog
         if(listSize == 0) {
//             char* page;
//             BufferTag bufferTag;
//             INIT_BUFFERTAG(bufferTag,rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);
//             if(!GetPageFromRocksdb(bufferTag, replayedLsn, &page)) {
//                 printf("%s Error, get replayed page failed\n", __func__ );
//                 return;
//             }

             _return.assign(basePage, BLCKSZ);
             // Put page to Rocksdb
             // If this basePage got from standAlone, then this page must be basePage(lsn = 1)
             if(!gotBasePageFromRocksDb) {
                 PutPage2Rocksdb(bufferTag, 1, basePage);
                 free(basePage);
             }
#ifdef ENABLE_FUNCTION_TIMING
             functionTiming.RecordTime(__LINE__);
#endif
#ifdef DEBUG_TIMING
             RECORD_TIMING(&start, &end, &readBufferCommon[9], &readBufferCount[9])
#endif
             return;
         }

#ifdef ENABLE_DEBUG_INFO
         printf("%s LINE=%d \n", __func__ , __LINE__);
         fflush(stdout);
#endif

         // For now, we need to replay several xlogs until we get the expected version
        // The xlog sublist we need to replay is [ uintList[1]+2 , foundPos ]



#ifdef ENABLE_DEBUG_INFO
         printf("%s LINE=%d \n", __func__ , __LINE__);
         fflush(stdout);
#endif

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &readBufferCommon[10], &readBufferCount[10])
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s LINE=%d \n", __func__ , __LINE__);
         fflush(stdout);
#endif
        char* page1 = (char*) malloc(BLCKSZ);
        char* page2 = (char*) malloc(BLCKSZ);
        char* tempPage;
        memcpy(page1, basePage, BLCKSZ);
        if(!gotBasePageFromRocksDb)
            free(basePage);

#ifdef ENABLE_DEBUG_INFO
         printf("%s LINE=%d basePageLsn = %lu, pageIsNew = %d\n", __func__ , __LINE__, PageGetLSN(page1), PageIsNew(page1));
         fflush(stdout);
#endif

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &readBufferCommon[11], &readBufferCount[11])
#endif
#ifdef ENABLE_FUNCTION_TIMING
        functionTiming.RecordTime(__LINE__);
#endif

        ApplyLsnList(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, reinterpret_cast<XLogRecPtr *>(toReplayList), listSize, page1, page2);
#ifdef ENABLE_FUNCTION_TIMING
        functionTiming.RecordTime(__LINE__);
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d, rel = %lu, replayLsnSize = %d targetLsn = %lu, page real lsn = %lu\n",
        __func__, __LINE__, rnode.relNode, listSize, toReplayList[listSize-1], PageGetLSN(page2));
        fflush(stdout);
#endif

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &readBufferCommon[12], &readBufferCount[12])
#endif

        PutPage2Rocksdb(bufferTag, toReplayList[listSize-1], page2);

#ifdef ENABLE_FUNCTION_TIMING
        functionTiming.RecordTime(__LINE__);
#endif
#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &readBufferCommon[13], &readBufferCount[13])
#endif
//        for(int i = 0; i < listSize; i++) {
//            //TODO Apply a lsn list, however, the middle of versions will miss
//            //TODO if other second comp node need these middle versions, we can repaly for them
//
//             printf("%s LINE=%d \n", __func__ , __LINE__);
//             fflush(stdout);
//
//             uint64_t currLsn = toReplayList[i];
//             if(currLsn <= replayedLsn)
//                 continue;
//             ApplyOneLsn(rnode, (ForkNumber)_forknum, (BlockNumber)_blknum, currLsn, page1, page2);
//             printf("%s LINE=%d \n", __func__ , __LINE__);
//             fflush(stdout);
//            // Now the page2 is replayed version, put it to rocksdb
//            PutPage2Rocksdb(bufferTag, currLsn, page2);
//            // Set the page2 as the input page for next round
//            tempPage = page1;
//            page1 = page2;
//            page2 = tempPage;
//        }
#ifdef ENABLE_DEBUG_INFO
         printf("%s LINE=%d \n", __func__ , __LINE__);
         fflush(stdout);
#endif


         if(listSize > 0) {
             HashMapUpdateReplayedLsn(pageVersionHashMap, key, toReplayList[listSize-1], true);

             free(toReplayList);
#ifdef ENABLE_FUNCTION_TIMING
             functionTiming.RecordTime(__LINE__);
#endif
         }

         // Delete base page
         if(gotBasePageFromRocksDb) {
             if(replayedLsn == 0)
                DeletePageFromRocksdb(bufferTag, 1);
             else
                 DeletePageFromRocksdb(bufferTag, replayedLsn);
#ifdef ENABLE_FUNCTION_TIMING
             functionTiming.RecordTime(__LINE__);
#endif
         }

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &readBufferCommon[14], &readBufferCount[14])
#endif

        //TODO: Return page2
        // Set the desired page version as return value
        _return.assign(page2, BLCKSZ);

        free(page1);
        free(page2);
//         printf("%s LINE=%d \n", __func__ , __LINE__);
//         fflush(stdout);

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &readBufferCommon[15], &readBufferCount[15])
#endif
//        char buff[BLCKSZ];
//        GetPageByLsn(rnode, (ForkNumber)_forknum, _blknum, 0, buff);
//        _return.assign(buff, BLCKSZ);
//
//        if(PageIsNew(buff)) {
//            printf("%s found page is new\n", __func__ );
//            fflush(stdout);
//        }
//        printf("%s End\n", __func__ );
    }

    void RpcMdRead(_Page& _return, const _Smgr_Relation& _reln, const int32_t _forknum, const int64_t _blknum, const int64_t _lsn) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blkNum = %ld\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum);
        fflush(stdout);
#endif
        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;
        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);

        WaitParse(_lsn);

        char buff[BLCKSZ];
        GetPageByLsn(rnode, (ForkNumber)_forknum, _blknum, 0, buff);
        _return.assign(buff, BLCKSZ);

#ifdef ENABLE_DEBUG_INFO
        printf("%s End\n", __func__ );
#endif
//        RelationData relationData;
//        memset(&relationData, 0, sizeof(RelationData));
//        Relation relation = &relationData;
//        relation->rd_smgr = smgrReln;

        // Not guarantee right
//        FormData_pg_class formDataPgClass;
//        formDataPgClass.relpersistence = RELPERSISTENCE_PERMANENT;
//        relation->rd_rel = &formDataPgClass;
//
//        Buffer buff = ReadBufferExtended(relation, (ForkNumber)_forknum, _blknum, RBM_NORMAL, NULL);
//
//        LockBuffer(buff, BUFFER_LOCK_SHARE);
//        char* page;
//        page = BufferGetPage(buff);
//
//        char tempPage[BLCKSZ];
//        memcpy(tempPage, page, BLCKSZ);
//
//        _return.resize(BLCKSZ);
//        _return.assign(tempPage, BLCKSZ);
//
//        UnlockReleaseBuffer(buff);

//        char page[BLCKSZ+16];
//        mdread(smgrReln, (ForkNumber)_forknum, _blknum, page);
//        _return.assign(page, BLCKSZ);
//
//        printf("%s end\n", __func__ );
//        fflush(stdout);
    }

    int32_t RpcMdNblocks(const _Smgr_Relation& _reln, const int32_t _forknum, const int64_t _lsn) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO2
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, lsn = %ld tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _lsn, gettid());
        fflush(stdout);
#endif
        // Your implementation goes here
//        SyncReplayProcess();

#ifdef DEBUG_TIMING
        struct timeval start, end;
        START_TIMING(&start);
#endif
        WaitParse(_lsn);

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &nblocksTime[4], &nblocksCount[4])
#endif
        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;
//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);

        XLogRecPtr lsn = _lsn;
        RelKey relKey;
        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);


#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &nblocksTime[0], &nblocksCount[0])
#endif

        uint32_t foundPageNum = 0;
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
        RelSizePthreadReadLock(relKey);
        if ( GetRelSizeCache(relKey, &foundPageNum) ) {
            RelSizePthreadUnlock(relKey);
#ifdef ENABLE_DEBUG_INFO2
            printf("%s cached, pageNum = %u\n", __func__, foundPageNum);
            fflush(stdout);
#endif
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &nblocksTime[1], &nblocksCount[1])
#endif
            return (int32_t)foundPageNum;
        }
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
        RelSizePthreadUnlock(relKey);

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &nblocksTime[2], &nblocksCount[2])
#endif
        int relSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, 0);
#ifdef ENABLE_DEBUG_INFO2
        printf("%s get relsize=%d from standalone pg\n", __func__ , relSize);
        fflush(stdout);
#endif
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
        RelSizePthreadWriteLock(relKey);
        uint32 tempResult = 0;
        if(relSize>=0 && GetRelSizeCache(relKey, &tempResult) == false)
            InsertRelSizeCache(relKey, (uint32) relSize);
        RelSizePthreadUnlock(relKey);
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);

//        BlockNumber result = mdnblocks(smgrReln, (ForkNumber)_forknum);
#ifdef ENABLE_DEBUG_INFO
        printf("%s end\n", __func__ );
        fflush(stdout);
#endif

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &nblocksTime[3], &nblocksCount[3])
#endif
        return relSize;
    }

    int32_t RpcMdExists(const _Smgr_Relation& _reln, const int32_t _forknum, const int64_t _lsn) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef DEBUG_TIMING
        struct timeval start, end;
        START_TIMING(&start);
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, lsn = %ld tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _lsn, gettid());
        fflush(stdout);
#endif

        WaitParse(_lsn);
//        SyncReplayProcess();

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

        RelKey relKey;
        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);

        uint32_t foundPageNum;
        RelSizePthreadReadLock(relKey);
        int found = GetRelSizeCache(relKey, &foundPageNum);
        RelSizePthreadUnlock(relKey);
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &existsTime[0], &existsCount[0])
#endif
        if(found) {
//            printf("%s %d\n", __func__ , __LINE__);
//            fflush(stdout);
#ifdef DEBUG_TIMING
            RECORD_TIMING(&start, &end, &existsTime[1], &existsCount[1])
#endif
                return 1;
        }
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);

//        SMgrRelation smgrReln = smgropen(rnode, InvalidBackendId);
//        int32_t result = mdexists(smgrReln, (ForkNumber)_forknum);

#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &existsTime[2], &existsCount[2])
#endif
        int relSize = SyncGetRelSize(rnode, (ForkNumber)_forknum, _lsn);
#ifdef ENABLE_DEBUG_INFO
        printf("%s get relsize=%d from standalone pg\n", __func__ , relSize);
#endif
        uint32 tempResult = -1;
        RelSizePthreadWriteLock(relKey);
        if(relSize >= 0 && GetRelSizeCache(relKey, &tempResult)==false)
            InsertRelSizeCache(relKey, (uint32)relSize);
        RelSizePthreadUnlock(relKey);
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);

#ifdef ENABLE_DEBUG_INFO
        printf("%s result = %d end\n", __func__, relSize);
        fflush(stdout);
#endif
#ifdef DEBUG_TIMING
        RECORD_TIMING(&start, &end, &existsTime[3], &existsCount[3])
#endif
        return (relSize>=0);
    }

    void RpcMdCreate(const _Smgr_Relation& _reln, const int32_t _forknum, const int32_t _isRedo, const int64_t _lsn) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, lsn = %lu tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _lsn, gettid());
        fflush(stdout);
#endif

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

#ifdef PASS
//        SyncReplayProcess();
        WaitParse(_lsn);

        RelKey relKey;
        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);

        uint64_t foundLsn;
        uint32 foundPageNum;
        RelSizePthreadWriteLock(relKey);
        int found = GetRelSizeCache(relKey, &foundPageNum);
        if(!found) {
            InsertRelSizeCache(relKey, 0);
        }
        RelSizePthreadUnlock(relKey);
#endif

//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);

        WalRedoCreateRel(rnode, (ForkNumber)_forknum);


#ifdef ENABLE_DEBUG_INFO
        printf("%s end\n", __func__);
        fflush(stdout);
#endif
    }

    void RpcMdExtend(const _Smgr_Relation& _reln, const int32_t _forknum, const int32_t _blknum, const _Page& _buff, const int32_t skipFsync, const int64_t _lsn) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
//        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blknum = %d lsn = %ld tid=%d\n", __func__ , __FILE__, __LINE__,
//               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
//        fflush(stdout);
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blknum = %d lsn = %ld tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
        fflush(stdout);
#endif

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

#ifdef PASS
//        SyncReplayProcess();
        WaitParse(_lsn);

        RelKey relKey;
        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);

//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
        uint64_t foundLsn;
        uint32_t foundPageNum;
        RelSizePthreadWriteLock(relKey);
        int found = GetRelSizeCache(relKey, &foundPageNum);
        //TODO: Here may have some problems: extend-page content's lsn is larger than parameter lsn
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d\n", __func__ , __LINE__);
        fflush(stdout);
#endif
        if(!found || foundPageNum<_blknum+1) {
            InsertRelSizeCache(relKey, _blknum+1);
        }
        RelSizePthreadUnlock(relKey);
#endif

//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d\n", __func__ , __LINE__);
        fflush(stdout);
#endif
        BufferTag tag;
        INIT_BUFFERTAG(tag, rnode, (ForkNumber)_forknum, (BlockNumber)_blknum);
        char *extendPage = (char*) malloc(BLCKSZ);

        _buff.copy(extendPage, BLCKSZ);

//        if(_blknum == 10 && rnode.relNode == 2659)
//            PageSetLSN(extendPage, 2);

#ifdef ENABLE_DEBUG_INFO
        printf("%s %d, parameter lsn = %lu\n", __func__ , __LINE__, PageGetLSN(extendPage));
        fflush(stdout);
#endif

        //TODO: maybe it not this reason
        /*!
         *  Important: Before we put this extended page to
         */
        // Put version:-1 to RocksDB
//        PutPage2Rocksdb(tag, 1, extendPage);
        WalRedoExtendRel(rnode, (ForkNumber) _forknum, (BlockNumber) _blknum, extendPage);
        free(extendPage);
//        char extendPage[BLCKSZ+16];
//        _buff.copy(extendPage, BLCKSZ);
//
#ifdef ENABLE_DEBUG_INFO
        printf("%s end\n", __func__);
        fflush(stdout);
#endif
    }


    void RpcTruncate(const _Smgr_Relation& _reln, const int32_t _forknum, const int32_t _blknum, const int64_t _lsn) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef ENABLE_DEBUG_INFO
        printf("%s %s %d , spcID = %ld, dbID = %ld, tabID = %ld, fornum = %d, blknum = %d lsn = %ld tid=%d\n", __func__ , __FILE__, __LINE__,
               _reln._spc_node, _reln._db_node, _reln._rel_node, _forknum, _blknum, _lsn, gettid());
        fflush(stdout);
#endif

        WaitParse(_lsn);

        RelFileNode rnode;
        rnode.spcNode = _reln._spc_node;
        rnode.dbNode = _reln._db_node;
        rnode.relNode = _reln._rel_node;

//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
        RelKey relKey;
        TransRelNode2RelKey(rnode, &relKey, (ForkNumber)_forknum);

        RelSizePthreadWriteLock(relKey);
        InsertRelSizeCache(relKey, _blknum);
        RelSizePthreadUnlock(relKey);
//        printf("%s %d\n", __func__ , __LINE__);
//        fflush(stdout);
    }


    // Following are fd.c interfaces
    void RpcFileClose(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        FileClose(_fd);
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
    }

    void RpcTablespaceCreateDbspace(const _Oid _spcnode, const _Oid _dbnode, const bool isRedo) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        TablespaceCreateDbspace(_spcnode, _dbnode, isRedo);
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
    }

    _File RpcPathNameOpenFile(const _Path& _path, const _Flag _flag) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start, filename = %s\n", __func__, _path.c_str() );
#endif
        _File result =  PathNameOpenFile(_path.c_str(), _flag);
//        printf("[%s] result = %d\n", __func__ , result);
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
        return result;
    }

    // todo
    int32_t RpcFileWrite(const _File _fd, const _Page& _page, const int32_t _amount, const _Off_t _seekpos, const int32_t _wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        // Your implementation goes here
        char buff[BLCKSZ+8];
        _page.copy(buff, BLCKSZ);
        return FileWrite(_fd, buff, _amount, _seekpos, _wait_event_info);

//        int writeLen = 0;
//        char * page = (char *) malloc(BLCKSZ);
//        _page.copy(page, BLCKSZ);
//
//        RpcRelation relNode = ParseRpcRequestPath(FilePathName(_fd), _seekpos);
//        if (relNode.parseSucc) {
//            writeLen = RpcFileWriteWithCache(_fd, page, relNode, _seekpos);
//        } else {
        //We arrived here only when some rare cases occur, for example, have backendID etc.
//            writeLen = FileWrite(_fd, page, _amount, _seekpos, _wait_event_info);
//        }
//
//        free(page);
//        return writeLen;
    }

    void RpcFilePathName(_Path& _return, const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        char * filename = FilePathName(_fd);
        _return.assign(filename);
#ifdef INFO_FUNC_END
        printf("%s end\n", __func__ );
#endif
        return;
    }

    // todo
    void RpcFileRead(_Page& _return, const _File _fd, const int32_t _amount, const _Off_t _seekpos, const int32_t _wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        char *page = (char *)malloc(BLCKSZ);
        int readLen = 0;

//        RpcRelation relNode = ParseRpcRequestPath(FilePathName(_fd), _seekpos);
//        printf("[%s]parse succ=%d, spc = %d, db = %d, rel = %d, fork = %d, block = %d\n",
//               __func__, relNode.parseSucc, relNode.spcNode, relNode.dbNode, relNode.relNode, relNode.forkNum, relNode.blockNum);
//        if (relNode.parseSucc) {
//            readLen = RpcFileReadWithCache(_fd, page, relNode, _seekpos);
//        } else {
        // We arrived here only when some rare cases occur, for example, have backendID etc.
        readLen = FileRead(_fd, page, _amount, _seekpos, _wait_event_info);
//        }

        _return.assign(page, readLen);
        free(page);
        return;
    }

    // todo
    int32_t RpcFileTruncate(const _File _fd, const _Off_t _offset) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s :start\n", __func__ );
#endif
        return FileTruncate(_fd, _offset, WAIT_EVENT_DATA_FILE_TRUNCATE);
    }

    _Off_t RpcFileSize(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start, fd = %d, tid = %d\n", __func__ , _fd, gettid());
#endif
        _Off_t result = FileSize(_fd);
#ifdef INFO_FUNC_END
        printf("%s end, tid = %d, fd = %d, result = %d\n", __func__ , gettid(), _fd, result);
#endif
        return result;
    }

    int32_t RpcFilePrefetch(const _File _fd, const _Off_t _offset, const int32_t _amount, const int32_t wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return FilePrefetch(_fd, _offset, _amount, wait_event_info);
    }

    void RpcFileWriteback(const _File _fd, const _Off_t _offset, const _Off_t nbytes, const int32_t wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        FileWriteback(_fd, _offset, nbytes, wait_event_info);
        return;
    }

    int32_t RpcUnlink(const _Path& _path) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return unlink(_path.c_str());
    }

    int32_t RpcFtruncate(const _File _fd, const _Off_t _offset) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return ftruncate(_fd, _offset);
    }

    void RpcInitFile(_Page& _return, const _Path& _path) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
    }

    _File RpcOpenTransientFile(const _Path& _filename, const int32_t _fileflags) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return OpenTransientFile(_filename.c_str(), _fileflags);
    }

    int32_t RpcCloseTransientFile(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return CloseTransientFile(_fd);
    }

    void Rpcread(_Page& _return, const _File _fd, const int32_t size) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
    }

    int32_t Rpcwrite(const _File _fd, const _Page& _page, const int32_t size) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
    }

    int32_t RpcFileSync(const _File _fd, const int32_t _wait_event_info) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return FileSync(_fd, _wait_event_info);
    }

    void RpcPgPRead(_Page& _return, const _File _fd, const int32_t _seg_bytes, const _Off_t _start_off) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        char *p = (char*)malloc(_seg_bytes+64);
         if(_start_off == -1) {
             read(_fd, p, _seg_bytes);
         } else {
             pg_pread(_fd, p, _seg_bytes, _start_off);
         }
        _return.assign(p, _seg_bytes);
        free(p);
        return;
    }

    int32_t RpcPgPWrite(const _File _fd, const _Page& _page, const int32_t _amount, const _Off_t _offset) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
         int32_t result;
         if(_offset == -1) {
             result = write(_fd, _page.c_str(), _amount);
         } else {
             result = pg_pwrite(_fd, _page.c_str(), _amount, _offset);
         }
//        printf("RpcPgPWrite, result = %d\n", result);
        return result;
    }

    int32_t RpcClose(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return close(_fd);
    }

    int32_t RpcBasicOpenFile(const _Path& _path, const int32_t _flags) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
        int32_t result = BasicOpenFile(_path.c_str(), _flags);
#ifdef INFO_FUNC_START
        printf("%s start, fileName = %s, result = %d\n", __func__ , _path.c_str(), result);
        fflush(stdout);
#endif
        return result;
    }

    int32_t RpcPgFdatasync(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return pg_fdatasync(_fd);
    }

    int32_t RpcPgFsyncNoWritethrough(const _File _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return pg_fsync_no_writethrough(_fd);
    }

    int32_t RpcLseek(const int32_t _fd, const _Off_t _offset, const int32_t _flag) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return lseek(_fd, _offset, _flag);
    }

    void RpcStat(_Stat_Resp& _return, const _Path& _path) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        struct stat result;
        _return._result = stat(_path.c_str(), &result);
        _return._stat_mode = result.st_mode;
        return;
    }

    int32_t RpcDirectoryIsEmpty(const _Path& _path) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return directory_is_empty(_path.c_str());
    }

    int32_t RpcCopyDir(const _Path& _src, const _Path& _dst) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        char* src = (char*) malloc(1024);
        char* dst = (char*) malloc(1024);
//        printf("_src = %s, dst = %s\n", _src.c_str(), _dst.c_str());
        _src.copy(src, _src.length());
        _dst.copy(dst, _dst.length());
        src[_src.length()] = 0;
        dst[_dst.length()] = 0;
//        printf("src = %s, dst = %s\n", src, dst);
        copydir(src, dst, false);
        free(src);
        free(dst);
        return 0;
    }

    int32_t RpcPgFsync(const int32_t _fd) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        int32_t result = pg_fsync(_fd);
//        printf("RpcPgFsync, result = %d\n", result);
        return result;
    }

    int32_t RpcDurableUnlink(const _Path& _fname, const int32_t _flag) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        return durable_unlink(_fname.c_str(), _flag);
    }

    int32_t RpcDurableRenameExcl(const _Path& _oldFname, const _Path& _newFname, const int32_t _elevel) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start, oldName = %s, newName = %s\n", __func__ , _oldFname.c_str(), _newFname.c_str());
        fflush(stdout);
#endif
        int32_t result =  durable_rename_excl(_oldFname.c_str(), _newFname.c_str(), _elevel);
#ifdef INFO_FUNC_START
        printf("%s end\n", __func__ );
        fflush(stdout);
#endif

        return result;
    }

    int32_t RpcXLogWrite(const _File _fd, const _Page& _page, const int32_t _amount, const _Off_t _offset, const std::vector<int64_t> & _xlblocks, const int32_t _blknum, const int32_t _idx, const int64_t _lsn) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
        // Your implementation goes here
#ifdef INFO_FUNC_START
        printf("%s %d, blockNum = %d, start_idx = %d, lsn = %ld\n", __func__ , __LINE__, _blknum, _idx, _lsn);
        for(int i = 0; i < _blknum; i++){
            printf("_xlblocks[%d] = %ld\n", i, _xlblocks[i]);
        }
        fflush(stdout);
        printf("%s %d, start lsn = %lu, end lsn = %ld\n", __func__ , __LINE__, _lsn, _xlblocks[_blknum-1]);
        fflush(stdout);
#endif


        int32_t result = pg_pwrite(_fd, _page.c_str(), _amount, _offset);

#ifdef ENABLE_DEBUG_INFO
        printf("%s %d\n", __func__ , __LINE__);
        fflush(stdout);
#endif

        // Need some lock
        for(int i = 0; i < _blknum; i++) {
#ifdef ENABLE_DEBUG_INFO
            printf("%s %d, try to get %d locks\n", __func__ , __LINE__, _idx+i);
            fflush(stdout);
#endif
            pthread_rwlock_wrlock(&(RpcXLogPagesLocks[(_idx+i)]));
            RpcXlblocks[(_idx+i)%XLOGbuffers] = _xlblocks[i];
        }

#ifdef ENABLE_DEBUG_INFO
        printf("%s %d\n", __func__ , __LINE__);
        fflush(stdout);
#endif

        // Based on XLogWrite code, startIdx+_blknum <= XLogBuffers-1
        // So, RpcXLogPages + (_idx*BLCKSZ) + (_blknum*BLCKSZ) will smaller than or equal with end of RpcXLogPages
        memcpy( RpcXLogPages+(XLOG_BLCKSZ*_idx), _page.c_str(), XLOG_BLCKSZ*_blknum );

        for(int i = 0; i < _blknum; i++) {
            pthread_rwlock_unlock(&(RpcXLogPagesLocks[(_idx+i)]));
#ifdef ENABLE_DEBUG_INFO
            printf("%s %d, released %d locks\n", __func__ , __LINE__, _idx+i);
            fflush(stdout);
#endif
        }

#ifdef ENABLE_DEBUG_INFO
        printf("%s %d\n", __func__ , __LINE__);
        fflush(stdout);
#endif
        if(RpcXLogFlushedLsn < _lsn) {
            RpcXLogFlushedLsn = (uint64_t) _lsn;
        }
        pthread_mutex_lock(&wakeupMutex);
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d\n", __func__ , __LINE__);
        fflush(stdout);
#endif
//        WakeupRecovery();
        WakeupStartupRecovery();
        pthread_mutex_unlock(&wakeupMutex);
#ifdef ENABLE_DEBUG_INFO
        printf("%s %d\n", __func__ , __LINE__);
        fflush(stdout);
#endif

        // sigusr1_handler(SIGNAL_ARGS) -> should send signal to RpcServer
        // how to set flushUpto? set it with _blknum-1 pages? Or XLogWrite also send XLogWriteResult.lsn to this function.

        return result;
    }

    void RpcXLogFileInit(_XLog_Init_File_Resp& _return, const int64_t _logsegno, const int32_t _use_existent, const int32_t _use_lock) {
#ifdef ENABLE_FUNCTION_TIMING
        FunctionTiming functionTiming(const_cast<char *>(__func__));
#endif
#ifdef INFO_FUNC_START
        printf("%s start\n", __func__ );
#endif
//        printf("%s start\n", __func__ );
//        fflush(stdout);

        bool use_existent = (_use_existent == 1);
        bool use_lock = (_use_lock == 1);

        int fd = XLogFileInit(_logsegno, &use_existent, use_lock);

        _return._fd = fd;
        _return._use_existent = use_existent;

    }


    /**
     * This method has a oneway modifier. That means the client only makes
     * a request and does not listen for any response at all. Oneway methods
     * must be void.
     */
    void zip() {
        // Your implementation goes here
        printf("zip\n");
    }

};


void
RpcServerLoop(void){
    int port = 9090;

    std::shared_ptr<concurrency::ThreadFactory> threadFactory = std::make_shared<concurrency::ThreadFactory>(new concurrency::ThreadFactory());
//    std::shared_ptr<concurrency::ThreadManager> threadManager = concurrency::ThreadManager::newThreadManager();
    std::shared_ptr<concurrency::ThreadManager> threadManager = concurrency::ThreadManager::newSimpleThreadManager(50);
    threadManager->threadFactory(threadFactory);
    threadManager->start();


//    TSimpleServer server(
//    TThreadedServer server(
    std::shared_ptr<server::TServer> server;
    server.reset ( new TThreadPoolServer(
            std::make_shared<DataPageAccessProcessor>(std::make_shared<DataPageAccessHandler>()),
            std::make_shared<TServerSocket>(port), //port
            std::make_shared<TBufferedTransportFactory>(),
            std::make_shared<TBinaryProtocolFactory>(),
            threadManager
            ) );

    concurrency::ThreadFactory factory;
    factory.setDetached(false);
    std::shared_ptr<apache::thrift::concurrency::Runnable> serverThreadRunner(server);
    std::shared_ptr<apache::thrift::concurrency::Thread> thread = factory.newThread(serverThreadRunner);
    thread->start();
    concurrency::Monitor gMonitor;
    gMonitor.waitForever();

    server->stop();
    thread->join();
    server.reset();
}
