/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DataPageAccess_H
#define DataPageAccess_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "tutorial_types.h"

namespace tutorial {

#define RPCPORT 9090

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

/**
 * Ahh, now onto the cool part, defining a service. Services just need a name
 * and can optionally inherit from another service using the extends keyword.
 */
class DataPageAccessIf {
 public:
  virtual ~DataPageAccessIf() {}

  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param _path
   * @param upperLSN
   * @param lowerLSN
   */
  virtual int64_t RpcKvNblocks(const _Path& _path, const int64_t upperLSN, const int64_t lowerLSN) = 0;
  virtual void RpcKvRead(_Page& _return, const _Oid _spcNode, const _Oid _dbNode, const _Oid _relNode, const int32_t fork, const int64_t block, const int64_t upperLSN, const int64_t lowerLSN) = 0;
  virtual void RpcInitFile(_Page& _return, const _Path& _path) = 0;
  virtual _File RpcOpenTransientFile(const _Path& _filename, const int32_t _fileflags) = 0;
  virtual void RpcCloseTransientFile(const _File _fd) = 0;
  virtual void Rpcread(_Page& _return, const _File _fd, const int32_t size) = 0;
  virtual int32_t Rpcwrite(const _File _fd, const _Page& _page, const int32_t size) = 0;

  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  virtual void zip() = 0;
};

class DataPageAccessIfFactory {
 public:
  typedef DataPageAccessIf Handler;

  virtual ~DataPageAccessIfFactory() {}

  virtual DataPageAccessIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(DataPageAccessIf* /* handler */) = 0;
};

class DataPageAccessIfSingletonFactory : virtual public DataPageAccessIfFactory {
 public:
  DataPageAccessIfSingletonFactory(const ::std::shared_ptr<DataPageAccessIf>& iface) : iface_(iface) {}
  virtual ~DataPageAccessIfSingletonFactory() {}

  virtual DataPageAccessIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(DataPageAccessIf* /* handler */) {}

 protected:
  ::std::shared_ptr<DataPageAccessIf> iface_;
};

class DataPageAccessNull : virtual public DataPageAccessIf {
 public:
  virtual ~DataPageAccessNull() {}
  int64_t RpcKvNblocks(const _Path& /* _path */, const int64_t /* upperLSN */, const int64_t /* lowerLSN */) {
    int64_t _return = 0;
    return _return;
  }
  void RpcKvRead(_Page& /* _return */, const _Oid /* _spcNode */, const _Oid /* _dbNode */, const _Oid /* _relNode */, const int32_t /* fork */, const int64_t /* block */, const int64_t /* upperLSN */, const int64_t /* lowerLSN */) {
    return;
  }
  void RpcInitFile(_Page& /* _return */, const _Path& /* _path */) {
    return;
  }
  _File RpcOpenTransientFile(const _Path& /* _filename */, const int32_t /* _fileflags */) {
    _File _return = 0;
    return _return;
  }
  void RpcCloseTransientFile(const _File /* _fd */) {
    return;
  }
  void Rpcread(_Page& /* _return */, const _File /* _fd */, const int32_t /* size */) {
    return;
  }
  int32_t Rpcwrite(const _File /* _fd */, const _Page& /* _page */, const int32_t /* size */) {
    int32_t _return = 0;
    return _return;
  }
  void zip() {
    return;
  }
};

typedef struct _DataPageAccess_RpcKvNblocks_args__isset {
  _DataPageAccess_RpcKvNblocks_args__isset() : _path(false), upperLSN(false), lowerLSN(false) {}
  bool _path :1;
  bool upperLSN :1;
  bool lowerLSN :1;
} _DataPageAccess_RpcKvNblocks_args__isset;

class DataPageAccess_RpcKvNblocks_args {
 public:

  DataPageAccess_RpcKvNblocks_args(const DataPageAccess_RpcKvNblocks_args&);
  DataPageAccess_RpcKvNblocks_args& operator=(const DataPageAccess_RpcKvNblocks_args&);
  DataPageAccess_RpcKvNblocks_args() : _path(), upperLSN(0), lowerLSN(0) {
  }

  virtual ~DataPageAccess_RpcKvNblocks_args() noexcept;
  _Path _path;
  int64_t upperLSN;
  int64_t lowerLSN;

  _DataPageAccess_RpcKvNblocks_args__isset __isset;

  void __set__path(const _Path& val);

  void __set_upperLSN(const int64_t val);

  void __set_lowerLSN(const int64_t val);

  bool operator == (const DataPageAccess_RpcKvNblocks_args & rhs) const
  {
    if (!(_path == rhs._path))
      return false;
    if (!(upperLSN == rhs.upperLSN))
      return false;
    if (!(lowerLSN == rhs.lowerLSN))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcKvNblocks_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcKvNblocks_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcKvNblocks_pargs {
 public:


  virtual ~DataPageAccess_RpcKvNblocks_pargs() noexcept;
  const _Path* _path;
  const int64_t* upperLSN;
  const int64_t* lowerLSN;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcKvNblocks_result__isset {
  _DataPageAccess_RpcKvNblocks_result__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcKvNblocks_result__isset;

class DataPageAccess_RpcKvNblocks_result {
 public:

  DataPageAccess_RpcKvNblocks_result(const DataPageAccess_RpcKvNblocks_result&);
  DataPageAccess_RpcKvNblocks_result& operator=(const DataPageAccess_RpcKvNblocks_result&);
  DataPageAccess_RpcKvNblocks_result() : success(0) {
  }

  virtual ~DataPageAccess_RpcKvNblocks_result() noexcept;
  int64_t success;

  _DataPageAccess_RpcKvNblocks_result__isset __isset;

  void __set_success(const int64_t val);

  bool operator == (const DataPageAccess_RpcKvNblocks_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcKvNblocks_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcKvNblocks_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcKvNblocks_presult__isset {
  _DataPageAccess_RpcKvNblocks_presult__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcKvNblocks_presult__isset;

class DataPageAccess_RpcKvNblocks_presult {
 public:


  virtual ~DataPageAccess_RpcKvNblocks_presult() noexcept;
  int64_t* success;

  _DataPageAccess_RpcKvNblocks_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcKvRead_args__isset {
  _DataPageAccess_RpcKvRead_args__isset() : _spcNode(false), _dbNode(false), _relNode(false), fork(false), block(false), upperLSN(false), lowerLSN(false) {}
  bool _spcNode :1;
  bool _dbNode :1;
  bool _relNode :1;
  bool fork :1;
  bool block :1;
  bool upperLSN :1;
  bool lowerLSN :1;
} _DataPageAccess_RpcKvRead_args__isset;

class DataPageAccess_RpcKvRead_args {
 public:

  DataPageAccess_RpcKvRead_args(const DataPageAccess_RpcKvRead_args&);
  DataPageAccess_RpcKvRead_args& operator=(const DataPageAccess_RpcKvRead_args&);
  DataPageAccess_RpcKvRead_args() : _spcNode(0), _dbNode(0), _relNode(0), fork(0), block(0), upperLSN(0), lowerLSN(0) {
  }

  virtual ~DataPageAccess_RpcKvRead_args() noexcept;
  _Oid _spcNode;
  _Oid _dbNode;
  _Oid _relNode;
  int32_t fork;
  int64_t block;
  int64_t upperLSN;
  int64_t lowerLSN;

  _DataPageAccess_RpcKvRead_args__isset __isset;

  void __set__spcNode(const _Oid val);

  void __set__dbNode(const _Oid val);

  void __set__relNode(const _Oid val);

  void __set_fork(const int32_t val);

  void __set_block(const int64_t val);

  void __set_upperLSN(const int64_t val);

  void __set_lowerLSN(const int64_t val);

  bool operator == (const DataPageAccess_RpcKvRead_args & rhs) const
  {
    if (!(_spcNode == rhs._spcNode))
      return false;
    if (!(_dbNode == rhs._dbNode))
      return false;
    if (!(_relNode == rhs._relNode))
      return false;
    if (!(fork == rhs.fork))
      return false;
    if (!(block == rhs.block))
      return false;
    if (!(upperLSN == rhs.upperLSN))
      return false;
    if (!(lowerLSN == rhs.lowerLSN))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcKvRead_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcKvRead_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcKvRead_pargs {
 public:


  virtual ~DataPageAccess_RpcKvRead_pargs() noexcept;
  const _Oid* _spcNode;
  const _Oid* _dbNode;
  const _Oid* _relNode;
  const int32_t* fork;
  const int64_t* block;
  const int64_t* upperLSN;
  const int64_t* lowerLSN;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcKvRead_result__isset {
  _DataPageAccess_RpcKvRead_result__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcKvRead_result__isset;

class DataPageAccess_RpcKvRead_result {
 public:

  DataPageAccess_RpcKvRead_result(const DataPageAccess_RpcKvRead_result&);
  DataPageAccess_RpcKvRead_result& operator=(const DataPageAccess_RpcKvRead_result&);
  DataPageAccess_RpcKvRead_result() : success() {
  }

  virtual ~DataPageAccess_RpcKvRead_result() noexcept;
  _Page success;

  _DataPageAccess_RpcKvRead_result__isset __isset;

  void __set_success(const _Page& val);

  bool operator == (const DataPageAccess_RpcKvRead_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcKvRead_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcKvRead_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcKvRead_presult__isset {
  _DataPageAccess_RpcKvRead_presult__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcKvRead_presult__isset;

class DataPageAccess_RpcKvRead_presult {
 public:


  virtual ~DataPageAccess_RpcKvRead_presult() noexcept;
  _Page* success;

  _DataPageAccess_RpcKvRead_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcInitFile_args__isset {
  _DataPageAccess_RpcInitFile_args__isset() : _path(false) {}
  bool _path :1;
} _DataPageAccess_RpcInitFile_args__isset;

class DataPageAccess_RpcInitFile_args {
 public:

  DataPageAccess_RpcInitFile_args(const DataPageAccess_RpcInitFile_args&);
  DataPageAccess_RpcInitFile_args& operator=(const DataPageAccess_RpcInitFile_args&);
  DataPageAccess_RpcInitFile_args() : _path() {
  }

  virtual ~DataPageAccess_RpcInitFile_args() noexcept;
  _Path _path;

  _DataPageAccess_RpcInitFile_args__isset __isset;

  void __set__path(const _Path& val);

  bool operator == (const DataPageAccess_RpcInitFile_args & rhs) const
  {
    if (!(_path == rhs._path))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcInitFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcInitFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcInitFile_pargs {
 public:


  virtual ~DataPageAccess_RpcInitFile_pargs() noexcept;
  const _Path* _path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcInitFile_result__isset {
  _DataPageAccess_RpcInitFile_result__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcInitFile_result__isset;

class DataPageAccess_RpcInitFile_result {
 public:

  DataPageAccess_RpcInitFile_result(const DataPageAccess_RpcInitFile_result&);
  DataPageAccess_RpcInitFile_result& operator=(const DataPageAccess_RpcInitFile_result&);
  DataPageAccess_RpcInitFile_result() : success() {
  }

  virtual ~DataPageAccess_RpcInitFile_result() noexcept;
  _Page success;

  _DataPageAccess_RpcInitFile_result__isset __isset;

  void __set_success(const _Page& val);

  bool operator == (const DataPageAccess_RpcInitFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcInitFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcInitFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcInitFile_presult__isset {
  _DataPageAccess_RpcInitFile_presult__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcInitFile_presult__isset;

class DataPageAccess_RpcInitFile_presult {
 public:


  virtual ~DataPageAccess_RpcInitFile_presult() noexcept;
  _Page* success;

  _DataPageAccess_RpcInitFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcOpenTransientFile_args__isset {
  _DataPageAccess_RpcOpenTransientFile_args__isset() : _filename(false), _fileflags(false) {}
  bool _filename :1;
  bool _fileflags :1;
} _DataPageAccess_RpcOpenTransientFile_args__isset;

class DataPageAccess_RpcOpenTransientFile_args {
 public:

  DataPageAccess_RpcOpenTransientFile_args(const DataPageAccess_RpcOpenTransientFile_args&);
  DataPageAccess_RpcOpenTransientFile_args& operator=(const DataPageAccess_RpcOpenTransientFile_args&);
  DataPageAccess_RpcOpenTransientFile_args() : _filename(), _fileflags(0) {
  }

  virtual ~DataPageAccess_RpcOpenTransientFile_args() noexcept;
  _Path _filename;
  int32_t _fileflags;

  _DataPageAccess_RpcOpenTransientFile_args__isset __isset;

  void __set__filename(const _Path& val);

  void __set__fileflags(const int32_t val);

  bool operator == (const DataPageAccess_RpcOpenTransientFile_args & rhs) const
  {
    if (!(_filename == rhs._filename))
      return false;
    if (!(_fileflags == rhs._fileflags))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcOpenTransientFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcOpenTransientFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcOpenTransientFile_pargs {
 public:


  virtual ~DataPageAccess_RpcOpenTransientFile_pargs() noexcept;
  const _Path* _filename;
  const int32_t* _fileflags;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcOpenTransientFile_result__isset {
  _DataPageAccess_RpcOpenTransientFile_result__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcOpenTransientFile_result__isset;

class DataPageAccess_RpcOpenTransientFile_result {
 public:

  DataPageAccess_RpcOpenTransientFile_result(const DataPageAccess_RpcOpenTransientFile_result&);
  DataPageAccess_RpcOpenTransientFile_result& operator=(const DataPageAccess_RpcOpenTransientFile_result&);
  DataPageAccess_RpcOpenTransientFile_result() : success(0) {
  }

  virtual ~DataPageAccess_RpcOpenTransientFile_result() noexcept;
  _File success;

  _DataPageAccess_RpcOpenTransientFile_result__isset __isset;

  void __set_success(const _File val);

  bool operator == (const DataPageAccess_RpcOpenTransientFile_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcOpenTransientFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcOpenTransientFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcOpenTransientFile_presult__isset {
  _DataPageAccess_RpcOpenTransientFile_presult__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcOpenTransientFile_presult__isset;

class DataPageAccess_RpcOpenTransientFile_presult {
 public:


  virtual ~DataPageAccess_RpcOpenTransientFile_presult() noexcept;
  _File* success;

  _DataPageAccess_RpcOpenTransientFile_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcCloseTransientFile_args__isset {
  _DataPageAccess_RpcCloseTransientFile_args__isset() : _fd(false) {}
  bool _fd :1;
} _DataPageAccess_RpcCloseTransientFile_args__isset;

class DataPageAccess_RpcCloseTransientFile_args {
 public:

  DataPageAccess_RpcCloseTransientFile_args(const DataPageAccess_RpcCloseTransientFile_args&);
  DataPageAccess_RpcCloseTransientFile_args& operator=(const DataPageAccess_RpcCloseTransientFile_args&);
  DataPageAccess_RpcCloseTransientFile_args() : _fd(0) {
  }

  virtual ~DataPageAccess_RpcCloseTransientFile_args() noexcept;
  _File _fd;

  _DataPageAccess_RpcCloseTransientFile_args__isset __isset;

  void __set__fd(const _File val);

  bool operator == (const DataPageAccess_RpcCloseTransientFile_args & rhs) const
  {
    if (!(_fd == rhs._fd))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcCloseTransientFile_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcCloseTransientFile_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcCloseTransientFile_pargs {
 public:


  virtual ~DataPageAccess_RpcCloseTransientFile_pargs() noexcept;
  const _File* _fd;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcCloseTransientFile_result {
 public:

  DataPageAccess_RpcCloseTransientFile_result(const DataPageAccess_RpcCloseTransientFile_result&);
  DataPageAccess_RpcCloseTransientFile_result& operator=(const DataPageAccess_RpcCloseTransientFile_result&);
  DataPageAccess_RpcCloseTransientFile_result() {
  }

  virtual ~DataPageAccess_RpcCloseTransientFile_result() noexcept;

  bool operator == (const DataPageAccess_RpcCloseTransientFile_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataPageAccess_RpcCloseTransientFile_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcCloseTransientFile_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcCloseTransientFile_presult {
 public:


  virtual ~DataPageAccess_RpcCloseTransientFile_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_Rpcread_args__isset {
  _DataPageAccess_Rpcread_args__isset() : _fd(false), size(false) {}
  bool _fd :1;
  bool size :1;
} _DataPageAccess_Rpcread_args__isset;

class DataPageAccess_Rpcread_args {
 public:

  DataPageAccess_Rpcread_args(const DataPageAccess_Rpcread_args&);
  DataPageAccess_Rpcread_args& operator=(const DataPageAccess_Rpcread_args&);
  DataPageAccess_Rpcread_args() : _fd(0), size(0) {
  }

  virtual ~DataPageAccess_Rpcread_args() noexcept;
  _File _fd;
  int32_t size;

  _DataPageAccess_Rpcread_args__isset __isset;

  void __set__fd(const _File val);

  void __set_size(const int32_t val);

  bool operator == (const DataPageAccess_Rpcread_args & rhs) const
  {
    if (!(_fd == rhs._fd))
      return false;
    if (!(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_Rpcread_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_Rpcread_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_Rpcread_pargs {
 public:


  virtual ~DataPageAccess_Rpcread_pargs() noexcept;
  const _File* _fd;
  const int32_t* size;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_Rpcread_result__isset {
  _DataPageAccess_Rpcread_result__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_Rpcread_result__isset;

class DataPageAccess_Rpcread_result {
 public:

  DataPageAccess_Rpcread_result(const DataPageAccess_Rpcread_result&);
  DataPageAccess_Rpcread_result& operator=(const DataPageAccess_Rpcread_result&);
  DataPageAccess_Rpcread_result() : success() {
  }

  virtual ~DataPageAccess_Rpcread_result() noexcept;
  _Page success;

  _DataPageAccess_Rpcread_result__isset __isset;

  void __set_success(const _Page& val);

  bool operator == (const DataPageAccess_Rpcread_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_Rpcread_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_Rpcread_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_Rpcread_presult__isset {
  _DataPageAccess_Rpcread_presult__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_Rpcread_presult__isset;

class DataPageAccess_Rpcread_presult {
 public:


  virtual ~DataPageAccess_Rpcread_presult() noexcept;
  _Page* success;

  _DataPageAccess_Rpcread_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_Rpcwrite_args__isset {
  _DataPageAccess_Rpcwrite_args__isset() : _fd(false), _page(false), size(false) {}
  bool _fd :1;
  bool _page :1;
  bool size :1;
} _DataPageAccess_Rpcwrite_args__isset;

class DataPageAccess_Rpcwrite_args {
 public:

  DataPageAccess_Rpcwrite_args(const DataPageAccess_Rpcwrite_args&);
  DataPageAccess_Rpcwrite_args& operator=(const DataPageAccess_Rpcwrite_args&);
  DataPageAccess_Rpcwrite_args() : _fd(0), _page(), size(0) {
  }

  virtual ~DataPageAccess_Rpcwrite_args() noexcept;
  _File _fd;
  _Page _page;
  int32_t size;

  _DataPageAccess_Rpcwrite_args__isset __isset;

  void __set__fd(const _File val);

  void __set__page(const _Page& val);

  void __set_size(const int32_t val);

  bool operator == (const DataPageAccess_Rpcwrite_args & rhs) const
  {
    if (!(_fd == rhs._fd))
      return false;
    if (!(_page == rhs._page))
      return false;
    if (!(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_Rpcwrite_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_Rpcwrite_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_Rpcwrite_pargs {
 public:


  virtual ~DataPageAccess_Rpcwrite_pargs() noexcept;
  const _File* _fd;
  const _Page* _page;
  const int32_t* size;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_Rpcwrite_result__isset {
  _DataPageAccess_Rpcwrite_result__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_Rpcwrite_result__isset;

class DataPageAccess_Rpcwrite_result {
 public:

  DataPageAccess_Rpcwrite_result(const DataPageAccess_Rpcwrite_result&);
  DataPageAccess_Rpcwrite_result& operator=(const DataPageAccess_Rpcwrite_result&);
  DataPageAccess_Rpcwrite_result() : success(0) {
  }

  virtual ~DataPageAccess_Rpcwrite_result() noexcept;
  int32_t success;

  _DataPageAccess_Rpcwrite_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const DataPageAccess_Rpcwrite_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_Rpcwrite_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_Rpcwrite_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_Rpcwrite_presult__isset {
  _DataPageAccess_Rpcwrite_presult__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_Rpcwrite_presult__isset;

class DataPageAccess_Rpcwrite_presult {
 public:


  virtual ~DataPageAccess_Rpcwrite_presult() noexcept;
  int32_t* success;

  _DataPageAccess_Rpcwrite_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DataPageAccess_zip_args {
 public:

  DataPageAccess_zip_args(const DataPageAccess_zip_args&);
  DataPageAccess_zip_args& operator=(const DataPageAccess_zip_args&);
  DataPageAccess_zip_args() {
  }

  virtual ~DataPageAccess_zip_args() noexcept;

  bool operator == (const DataPageAccess_zip_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataPageAccess_zip_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_zip_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_zip_pargs {
 public:


  virtual ~DataPageAccess_zip_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class DataPageAccessClient : virtual public DataPageAccessIf {
 public:
  DataPageAccessClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  DataPageAccessClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param _path
   * @param upperLSN
   * @param lowerLSN
   */
  int64_t RpcKvNblocks(const _Path& _path, const int64_t upperLSN, const int64_t lowerLSN);
  void send_RpcKvNblocks(const _Path& _path, const int64_t upperLSN, const int64_t lowerLSN);
  int64_t recv_RpcKvNblocks();
  void RpcKvRead(_Page& _return, const _Oid _spcNode, const _Oid _dbNode, const _Oid _relNode, const int32_t fork, const int64_t block, const int64_t upperLSN, const int64_t lowerLSN);
  void send_RpcKvRead(const _Oid _spcNode, const _Oid _dbNode, const _Oid _relNode, const int32_t fork, const int64_t block, const int64_t upperLSN, const int64_t lowerLSN);
  void recv_RpcKvRead(_Page& _return);
  void RpcInitFile(_Page& _return, const _Path& _path);
  void send_RpcInitFile(const _Path& _path);
  void recv_RpcInitFile(_Page& _return);
  _File RpcOpenTransientFile(const _Path& _filename, const int32_t _fileflags);
  void send_RpcOpenTransientFile(const _Path& _filename, const int32_t _fileflags);
  _File recv_RpcOpenTransientFile();
  void RpcCloseTransientFile(const _File _fd);
  void send_RpcCloseTransientFile(const _File _fd);
  void recv_RpcCloseTransientFile();
  void Rpcread(_Page& _return, const _File _fd, const int32_t size);
  void send_Rpcread(const _File _fd, const int32_t size);
  void recv_Rpcread(_Page& _return);
  int32_t Rpcwrite(const _File _fd, const _Page& _page, const int32_t size);
  void send_Rpcwrite(const _File _fd, const _Page& _page, const int32_t size);
  int32_t recv_Rpcwrite();
  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  void zip();
  void send_zip();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class DataPageAccessProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<DataPageAccessIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (DataPageAccessProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_RpcKvNblocks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcKvRead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcInitFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcOpenTransientFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcCloseTransientFile(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Rpcread(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Rpcwrite(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_zip(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  DataPageAccessProcessor(::std::shared_ptr<DataPageAccessIf> iface) :
    iface_(iface) {
    processMap_["RpcKvNblocks"] = &DataPageAccessProcessor::process_RpcKvNblocks;
    processMap_["RpcKvRead"] = &DataPageAccessProcessor::process_RpcKvRead;
    processMap_["RpcInitFile"] = &DataPageAccessProcessor::process_RpcInitFile;
    processMap_["RpcOpenTransientFile"] = &DataPageAccessProcessor::process_RpcOpenTransientFile;
    processMap_["RpcCloseTransientFile"] = &DataPageAccessProcessor::process_RpcCloseTransientFile;
    processMap_["Rpcread"] = &DataPageAccessProcessor::process_Rpcread;
    processMap_["Rpcwrite"] = &DataPageAccessProcessor::process_Rpcwrite;
    processMap_["zip"] = &DataPageAccessProcessor::process_zip;
  }

  virtual ~DataPageAccessProcessor() {}
};

class DataPageAccessProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  DataPageAccessProcessorFactory(const ::std::shared_ptr< DataPageAccessIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::std::shared_ptr< DataPageAccessIfFactory > handlerFactory_;
};

class DataPageAccessMultiface : virtual public DataPageAccessIf {
 public:
  DataPageAccessMultiface(std::vector<std::shared_ptr<DataPageAccessIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~DataPageAccessMultiface() {}
 protected:
  std::vector<std::shared_ptr<DataPageAccessIf> > ifaces_;
  DataPageAccessMultiface() {}
  void add(::std::shared_ptr<DataPageAccessIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param _path
   * @param upperLSN
   * @param lowerLSN
   */
  int64_t RpcKvNblocks(const _Path& _path, const int64_t upperLSN, const int64_t lowerLSN) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcKvNblocks(_path, upperLSN, lowerLSN);
    }
    return ifaces_[i]->RpcKvNblocks(_path, upperLSN, lowerLSN);
  }

  void RpcKvRead(_Page& _return, const _Oid _spcNode, const _Oid _dbNode, const _Oid _relNode, const int32_t fork, const int64_t block, const int64_t upperLSN, const int64_t lowerLSN) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcKvRead(_return, _spcNode, _dbNode, _relNode, fork, block, upperLSN, lowerLSN);
    }
    ifaces_[i]->RpcKvRead(_return, _spcNode, _dbNode, _relNode, fork, block, upperLSN, lowerLSN);
    return;
  }

  void RpcInitFile(_Page& _return, const _Path& _path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcInitFile(_return, _path);
    }
    ifaces_[i]->RpcInitFile(_return, _path);
    return;
  }

  _File RpcOpenTransientFile(const _Path& _filename, const int32_t _fileflags) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcOpenTransientFile(_filename, _fileflags);
    }
    return ifaces_[i]->RpcOpenTransientFile(_filename, _fileflags);
  }

  void RpcCloseTransientFile(const _File _fd) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcCloseTransientFile(_fd);
    }
    ifaces_[i]->RpcCloseTransientFile(_fd);
  }

  void Rpcread(_Page& _return, const _File _fd, const int32_t size) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Rpcread(_return, _fd, size);
    }
    ifaces_[i]->Rpcread(_return, _fd, size);
    return;
  }

  int32_t Rpcwrite(const _File _fd, const _Page& _page, const int32_t size) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Rpcwrite(_fd, _page, size);
    }
    return ifaces_[i]->Rpcwrite(_fd, _page, size);
  }

  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  void zip() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->zip();
    }
    ifaces_[i]->zip();
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class DataPageAccessConcurrentClient : virtual public DataPageAccessIf {
 public:
  DataPageAccessConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  DataPageAccessConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param _path
   * @param upperLSN
   * @param lowerLSN
   */
  int64_t RpcKvNblocks(const _Path& _path, const int64_t upperLSN, const int64_t lowerLSN);
  int32_t send_RpcKvNblocks(const _Path& _path, const int64_t upperLSN, const int64_t lowerLSN);
  int64_t recv_RpcKvNblocks(const int32_t seqid);
  void RpcKvRead(_Page& _return, const _Oid _spcNode, const _Oid _dbNode, const _Oid _relNode, const int32_t fork, const int64_t block, const int64_t upperLSN, const int64_t lowerLSN);
  int32_t send_RpcKvRead(const _Oid _spcNode, const _Oid _dbNode, const _Oid _relNode, const int32_t fork, const int64_t block, const int64_t upperLSN, const int64_t lowerLSN);
  void recv_RpcKvRead(_Page& _return, const int32_t seqid);
  void RpcInitFile(_Page& _return, const _Path& _path);
  int32_t send_RpcInitFile(const _Path& _path);
  void recv_RpcInitFile(_Page& _return, const int32_t seqid);
  _File RpcOpenTransientFile(const _Path& _filename, const int32_t _fileflags);
  int32_t send_RpcOpenTransientFile(const _Path& _filename, const int32_t _fileflags);
  _File recv_RpcOpenTransientFile(const int32_t seqid);
  void RpcCloseTransientFile(const _File _fd);
  int32_t send_RpcCloseTransientFile(const _File _fd);
  void recv_RpcCloseTransientFile(const int32_t seqid);
  void Rpcread(_Page& _return, const _File _fd, const int32_t size);
  int32_t send_Rpcread(const _File _fd, const int32_t size);
  void recv_Rpcread(_Page& _return, const int32_t seqid);
  int32_t Rpcwrite(const _File _fd, const _Page& _page, const int32_t size);
  int32_t send_Rpcwrite(const _File _fd, const _Page& _page, const int32_t size);
  int32_t recv_Rpcwrite(const int32_t seqid);
  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  void zip();
  void send_zip();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

} // namespace

#endif
