/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef DataPageAccess_H
#define DataPageAccess_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "tutorial_types.h"

namespace tutorial {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

/**
 * Ahh, now onto the cool part, defining a service. Services just need a name
 * and can optionally inherit from another service using the extends keyword.
 */
class DataPageAccessIf {
 public:
  virtual ~DataPageAccessIf() {}

  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param fd
   */
  virtual void RpcFileClose(const File fd) = 0;
  virtual File RpcFileCreate(const _RelFileNode& node, const _ForkNumber::type forkNum) = 0;
  virtual void RpcFileUnlink(const _RelFileNode& node, const _ForkNumber::type forkNum) = 0;
  virtual void RpcFileExtend(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum) = 0;
  virtual void RpcFileRead(_Page& _return, const File fd, const _BlockNumber blocknum) = 0;
  virtual void RpcFileWrite(const File fd, const _Page& page, const _BlockNumber blocknum) = 0;
  virtual _BlockNumber RpcFileNblocks(const _RelFileNode& node, const _ForkNumber::type forkNum) = 0;
  virtual void RpcFileTruncate(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum) = 0;

  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  virtual void zip() = 0;
};

class DataPageAccessIfFactory {
 public:
  typedef DataPageAccessIf Handler;

  virtual ~DataPageAccessIfFactory() {}

  virtual DataPageAccessIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(DataPageAccessIf* /* handler */) = 0;
};

class DataPageAccessIfSingletonFactory : virtual public DataPageAccessIfFactory {
 public:
  DataPageAccessIfSingletonFactory(const ::std::shared_ptr<DataPageAccessIf>& iface) : iface_(iface) {}
  virtual ~DataPageAccessIfSingletonFactory() {}

  virtual DataPageAccessIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(DataPageAccessIf* /* handler */) {}

 protected:
  ::std::shared_ptr<DataPageAccessIf> iface_;
};

class DataPageAccessNull : virtual public DataPageAccessIf {
 public:
  virtual ~DataPageAccessNull() {}
  void RpcFileClose(const File /* fd */) {
    return;
  }
  File RpcFileCreate(const _RelFileNode& /* node */, const _ForkNumber::type /* forkNum */) {
    File _return = 0;
    return _return;
  }
  void RpcFileUnlink(const _RelFileNode& /* node */, const _ForkNumber::type /* forkNum */) {
    return;
  }
  void RpcFileExtend(const _RelFileNode& /* node */, const _ForkNumber::type /* forkNum */, const _BlockNumber /* blocknum */) {
    return;
  }
  void RpcFileRead(_Page& /* _return */, const File /* fd */, const _BlockNumber /* blocknum */) {
    return;
  }
  void RpcFileWrite(const File /* fd */, const _Page& /* page */, const _BlockNumber /* blocknum */) {
    return;
  }
  _BlockNumber RpcFileNblocks(const _RelFileNode& /* node */, const _ForkNumber::type /* forkNum */) {
    _BlockNumber _return = 0;
    return _return;
  }
  void RpcFileTruncate(const _RelFileNode& /* node */, const _ForkNumber::type /* forkNum */, const _BlockNumber /* blocknum */) {
    return;
  }
  void zip() {
    return;
  }
};

typedef struct _DataPageAccess_RpcFileClose_args__isset {
  _DataPageAccess_RpcFileClose_args__isset() : fd(false) {}
  bool fd :1;
} _DataPageAccess_RpcFileClose_args__isset;

class DataPageAccess_RpcFileClose_args {
 public:

  DataPageAccess_RpcFileClose_args(const DataPageAccess_RpcFileClose_args&);
  DataPageAccess_RpcFileClose_args& operator=(const DataPageAccess_RpcFileClose_args&);
  DataPageAccess_RpcFileClose_args() : fd(0) {
  }

  virtual ~DataPageAccess_RpcFileClose_args() noexcept;
  File fd;

  _DataPageAccess_RpcFileClose_args__isset __isset;

  void __set_fd(const File val);

  bool operator == (const DataPageAccess_RpcFileClose_args & rhs) const
  {
    if (!(fd == rhs.fd))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileClose_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileClose_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileClose_pargs {
 public:


  virtual ~DataPageAccess_RpcFileClose_pargs() noexcept;
  const File* fd;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileClose_result {
 public:

  DataPageAccess_RpcFileClose_result(const DataPageAccess_RpcFileClose_result&);
  DataPageAccess_RpcFileClose_result& operator=(const DataPageAccess_RpcFileClose_result&);
  DataPageAccess_RpcFileClose_result() {
  }

  virtual ~DataPageAccess_RpcFileClose_result() noexcept;

  bool operator == (const DataPageAccess_RpcFileClose_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileClose_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileClose_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileClose_presult {
 public:


  virtual ~DataPageAccess_RpcFileClose_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcFileCreate_args__isset {
  _DataPageAccess_RpcFileCreate_args__isset() : node(false), forkNum(false) {}
  bool node :1;
  bool forkNum :1;
} _DataPageAccess_RpcFileCreate_args__isset;

class DataPageAccess_RpcFileCreate_args {
 public:

  DataPageAccess_RpcFileCreate_args(const DataPageAccess_RpcFileCreate_args&);
  DataPageAccess_RpcFileCreate_args& operator=(const DataPageAccess_RpcFileCreate_args&);
  DataPageAccess_RpcFileCreate_args() : forkNum((_ForkNumber::type)0) {
  }

  virtual ~DataPageAccess_RpcFileCreate_args() noexcept;
  _RelFileNode node;
  /**
   * 
   * @see _ForkNumber
   */
  _ForkNumber::type forkNum;

  _DataPageAccess_RpcFileCreate_args__isset __isset;

  void __set_node(const _RelFileNode& val);

  void __set_forkNum(const _ForkNumber::type val);

  bool operator == (const DataPageAccess_RpcFileCreate_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(forkNum == rhs.forkNum))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileCreate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileCreate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileCreate_pargs {
 public:


  virtual ~DataPageAccess_RpcFileCreate_pargs() noexcept;
  const _RelFileNode* node;
  /**
   * 
   * @see _ForkNumber
   */
  const _ForkNumber::type* forkNum;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcFileCreate_result__isset {
  _DataPageAccess_RpcFileCreate_result__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcFileCreate_result__isset;

class DataPageAccess_RpcFileCreate_result {
 public:

  DataPageAccess_RpcFileCreate_result(const DataPageAccess_RpcFileCreate_result&);
  DataPageAccess_RpcFileCreate_result& operator=(const DataPageAccess_RpcFileCreate_result&);
  DataPageAccess_RpcFileCreate_result() : success(0) {
  }

  virtual ~DataPageAccess_RpcFileCreate_result() noexcept;
  File success;

  _DataPageAccess_RpcFileCreate_result__isset __isset;

  void __set_success(const File val);

  bool operator == (const DataPageAccess_RpcFileCreate_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileCreate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileCreate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcFileCreate_presult__isset {
  _DataPageAccess_RpcFileCreate_presult__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcFileCreate_presult__isset;

class DataPageAccess_RpcFileCreate_presult {
 public:


  virtual ~DataPageAccess_RpcFileCreate_presult() noexcept;
  File* success;

  _DataPageAccess_RpcFileCreate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcFileUnlink_args__isset {
  _DataPageAccess_RpcFileUnlink_args__isset() : node(false), forkNum(false) {}
  bool node :1;
  bool forkNum :1;
} _DataPageAccess_RpcFileUnlink_args__isset;

class DataPageAccess_RpcFileUnlink_args {
 public:

  DataPageAccess_RpcFileUnlink_args(const DataPageAccess_RpcFileUnlink_args&);
  DataPageAccess_RpcFileUnlink_args& operator=(const DataPageAccess_RpcFileUnlink_args&);
  DataPageAccess_RpcFileUnlink_args() : forkNum((_ForkNumber::type)0) {
  }

  virtual ~DataPageAccess_RpcFileUnlink_args() noexcept;
  _RelFileNode node;
  /**
   * 
   * @see _ForkNumber
   */
  _ForkNumber::type forkNum;

  _DataPageAccess_RpcFileUnlink_args__isset __isset;

  void __set_node(const _RelFileNode& val);

  void __set_forkNum(const _ForkNumber::type val);

  bool operator == (const DataPageAccess_RpcFileUnlink_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(forkNum == rhs.forkNum))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileUnlink_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileUnlink_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileUnlink_pargs {
 public:


  virtual ~DataPageAccess_RpcFileUnlink_pargs() noexcept;
  const _RelFileNode* node;
  /**
   * 
   * @see _ForkNumber
   */
  const _ForkNumber::type* forkNum;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileUnlink_result {
 public:

  DataPageAccess_RpcFileUnlink_result(const DataPageAccess_RpcFileUnlink_result&);
  DataPageAccess_RpcFileUnlink_result& operator=(const DataPageAccess_RpcFileUnlink_result&);
  DataPageAccess_RpcFileUnlink_result() {
  }

  virtual ~DataPageAccess_RpcFileUnlink_result() noexcept;

  bool operator == (const DataPageAccess_RpcFileUnlink_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileUnlink_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileUnlink_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileUnlink_presult {
 public:


  virtual ~DataPageAccess_RpcFileUnlink_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcFileExtend_args__isset {
  _DataPageAccess_RpcFileExtend_args__isset() : node(false), forkNum(false), blocknum(false) {}
  bool node :1;
  bool forkNum :1;
  bool blocknum :1;
} _DataPageAccess_RpcFileExtend_args__isset;

class DataPageAccess_RpcFileExtend_args {
 public:

  DataPageAccess_RpcFileExtend_args(const DataPageAccess_RpcFileExtend_args&);
  DataPageAccess_RpcFileExtend_args& operator=(const DataPageAccess_RpcFileExtend_args&);
  DataPageAccess_RpcFileExtend_args() : forkNum((_ForkNumber::type)0), blocknum(0) {
  }

  virtual ~DataPageAccess_RpcFileExtend_args() noexcept;
  _RelFileNode node;
  /**
   * 
   * @see _ForkNumber
   */
  _ForkNumber::type forkNum;
  _BlockNumber blocknum;

  _DataPageAccess_RpcFileExtend_args__isset __isset;

  void __set_node(const _RelFileNode& val);

  void __set_forkNum(const _ForkNumber::type val);

  void __set_blocknum(const _BlockNumber val);

  bool operator == (const DataPageAccess_RpcFileExtend_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(forkNum == rhs.forkNum))
      return false;
    if (!(blocknum == rhs.blocknum))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileExtend_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileExtend_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileExtend_pargs {
 public:


  virtual ~DataPageAccess_RpcFileExtend_pargs() noexcept;
  const _RelFileNode* node;
  /**
   * 
   * @see _ForkNumber
   */
  const _ForkNumber::type* forkNum;
  const _BlockNumber* blocknum;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileExtend_result {
 public:

  DataPageAccess_RpcFileExtend_result(const DataPageAccess_RpcFileExtend_result&);
  DataPageAccess_RpcFileExtend_result& operator=(const DataPageAccess_RpcFileExtend_result&);
  DataPageAccess_RpcFileExtend_result() {
  }

  virtual ~DataPageAccess_RpcFileExtend_result() noexcept;

  bool operator == (const DataPageAccess_RpcFileExtend_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileExtend_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileExtend_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileExtend_presult {
 public:


  virtual ~DataPageAccess_RpcFileExtend_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcFileRead_args__isset {
  _DataPageAccess_RpcFileRead_args__isset() : fd(false), blocknum(false) {}
  bool fd :1;
  bool blocknum :1;
} _DataPageAccess_RpcFileRead_args__isset;

class DataPageAccess_RpcFileRead_args {
 public:

  DataPageAccess_RpcFileRead_args(const DataPageAccess_RpcFileRead_args&);
  DataPageAccess_RpcFileRead_args& operator=(const DataPageAccess_RpcFileRead_args&);
  DataPageAccess_RpcFileRead_args() : fd(0), blocknum(0) {
  }

  virtual ~DataPageAccess_RpcFileRead_args() noexcept;
  File fd;
  _BlockNumber blocknum;

  _DataPageAccess_RpcFileRead_args__isset __isset;

  void __set_fd(const File val);

  void __set_blocknum(const _BlockNumber val);

  bool operator == (const DataPageAccess_RpcFileRead_args & rhs) const
  {
    if (!(fd == rhs.fd))
      return false;
    if (!(blocknum == rhs.blocknum))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileRead_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileRead_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileRead_pargs {
 public:


  virtual ~DataPageAccess_RpcFileRead_pargs() noexcept;
  const File* fd;
  const _BlockNumber* blocknum;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcFileRead_result__isset {
  _DataPageAccess_RpcFileRead_result__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcFileRead_result__isset;

class DataPageAccess_RpcFileRead_result {
 public:

  DataPageAccess_RpcFileRead_result(const DataPageAccess_RpcFileRead_result&);
  DataPageAccess_RpcFileRead_result& operator=(const DataPageAccess_RpcFileRead_result&);
  DataPageAccess_RpcFileRead_result() {
  }

  virtual ~DataPageAccess_RpcFileRead_result() noexcept;
  _Page success;

  _DataPageAccess_RpcFileRead_result__isset __isset;

  void __set_success(const _Page& val);

  bool operator == (const DataPageAccess_RpcFileRead_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileRead_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileRead_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcFileRead_presult__isset {
  _DataPageAccess_RpcFileRead_presult__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcFileRead_presult__isset;

class DataPageAccess_RpcFileRead_presult {
 public:


  virtual ~DataPageAccess_RpcFileRead_presult() noexcept;
  _Page* success;

  _DataPageAccess_RpcFileRead_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcFileWrite_args__isset {
  _DataPageAccess_RpcFileWrite_args__isset() : fd(false), page(false), blocknum(false) {}
  bool fd :1;
  bool page :1;
  bool blocknum :1;
} _DataPageAccess_RpcFileWrite_args__isset;

class DataPageAccess_RpcFileWrite_args {
 public:

  DataPageAccess_RpcFileWrite_args(const DataPageAccess_RpcFileWrite_args&);
  DataPageAccess_RpcFileWrite_args& operator=(const DataPageAccess_RpcFileWrite_args&);
  DataPageAccess_RpcFileWrite_args() : fd(0), blocknum(0) {
  }

  virtual ~DataPageAccess_RpcFileWrite_args() noexcept;
  File fd;
  _Page page;
  _BlockNumber blocknum;

  _DataPageAccess_RpcFileWrite_args__isset __isset;

  void __set_fd(const File val);

  void __set_page(const _Page& val);

  void __set_blocknum(const _BlockNumber val);

  bool operator == (const DataPageAccess_RpcFileWrite_args & rhs) const
  {
    if (!(fd == rhs.fd))
      return false;
    if (!(page == rhs.page))
      return false;
    if (!(blocknum == rhs.blocknum))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileWrite_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileWrite_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileWrite_pargs {
 public:


  virtual ~DataPageAccess_RpcFileWrite_pargs() noexcept;
  const File* fd;
  const _Page* page;
  const _BlockNumber* blocknum;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileWrite_result {
 public:

  DataPageAccess_RpcFileWrite_result(const DataPageAccess_RpcFileWrite_result&);
  DataPageAccess_RpcFileWrite_result& operator=(const DataPageAccess_RpcFileWrite_result&);
  DataPageAccess_RpcFileWrite_result() {
  }

  virtual ~DataPageAccess_RpcFileWrite_result() noexcept;

  bool operator == (const DataPageAccess_RpcFileWrite_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileWrite_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileWrite_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileWrite_presult {
 public:


  virtual ~DataPageAccess_RpcFileWrite_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcFileNblocks_args__isset {
  _DataPageAccess_RpcFileNblocks_args__isset() : node(false), forkNum(false) {}
  bool node :1;
  bool forkNum :1;
} _DataPageAccess_RpcFileNblocks_args__isset;

class DataPageAccess_RpcFileNblocks_args {
 public:

  DataPageAccess_RpcFileNblocks_args(const DataPageAccess_RpcFileNblocks_args&);
  DataPageAccess_RpcFileNblocks_args& operator=(const DataPageAccess_RpcFileNblocks_args&);
  DataPageAccess_RpcFileNblocks_args() : forkNum((_ForkNumber::type)0) {
  }

  virtual ~DataPageAccess_RpcFileNblocks_args() noexcept;
  _RelFileNode node;
  /**
   * 
   * @see _ForkNumber
   */
  _ForkNumber::type forkNum;

  _DataPageAccess_RpcFileNblocks_args__isset __isset;

  void __set_node(const _RelFileNode& val);

  void __set_forkNum(const _ForkNumber::type val);

  bool operator == (const DataPageAccess_RpcFileNblocks_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(forkNum == rhs.forkNum))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileNblocks_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileNblocks_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileNblocks_pargs {
 public:


  virtual ~DataPageAccess_RpcFileNblocks_pargs() noexcept;
  const _RelFileNode* node;
  /**
   * 
   * @see _ForkNumber
   */
  const _ForkNumber::type* forkNum;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcFileNblocks_result__isset {
  _DataPageAccess_RpcFileNblocks_result__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcFileNblocks_result__isset;

class DataPageAccess_RpcFileNblocks_result {
 public:

  DataPageAccess_RpcFileNblocks_result(const DataPageAccess_RpcFileNblocks_result&);
  DataPageAccess_RpcFileNblocks_result& operator=(const DataPageAccess_RpcFileNblocks_result&);
  DataPageAccess_RpcFileNblocks_result() : success(0) {
  }

  virtual ~DataPageAccess_RpcFileNblocks_result() noexcept;
  _BlockNumber success;

  _DataPageAccess_RpcFileNblocks_result__isset __isset;

  void __set_success(const _BlockNumber val);

  bool operator == (const DataPageAccess_RpcFileNblocks_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileNblocks_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileNblocks_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _DataPageAccess_RpcFileNblocks_presult__isset {
  _DataPageAccess_RpcFileNblocks_presult__isset() : success(false) {}
  bool success :1;
} _DataPageAccess_RpcFileNblocks_presult__isset;

class DataPageAccess_RpcFileNblocks_presult {
 public:


  virtual ~DataPageAccess_RpcFileNblocks_presult() noexcept;
  _BlockNumber* success;

  _DataPageAccess_RpcFileNblocks_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _DataPageAccess_RpcFileTruncate_args__isset {
  _DataPageAccess_RpcFileTruncate_args__isset() : node(false), forkNum(false), blocknum(false) {}
  bool node :1;
  bool forkNum :1;
  bool blocknum :1;
} _DataPageAccess_RpcFileTruncate_args__isset;

class DataPageAccess_RpcFileTruncate_args {
 public:

  DataPageAccess_RpcFileTruncate_args(const DataPageAccess_RpcFileTruncate_args&);
  DataPageAccess_RpcFileTruncate_args& operator=(const DataPageAccess_RpcFileTruncate_args&);
  DataPageAccess_RpcFileTruncate_args() : forkNum((_ForkNumber::type)0), blocknum(0) {
  }

  virtual ~DataPageAccess_RpcFileTruncate_args() noexcept;
  _RelFileNode node;
  /**
   * 
   * @see _ForkNumber
   */
  _ForkNumber::type forkNum;
  _BlockNumber blocknum;

  _DataPageAccess_RpcFileTruncate_args__isset __isset;

  void __set_node(const _RelFileNode& val);

  void __set_forkNum(const _ForkNumber::type val);

  void __set_blocknum(const _BlockNumber val);

  bool operator == (const DataPageAccess_RpcFileTruncate_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(forkNum == rhs.forkNum))
      return false;
    if (!(blocknum == rhs.blocknum))
      return false;
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileTruncate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileTruncate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileTruncate_pargs {
 public:


  virtual ~DataPageAccess_RpcFileTruncate_pargs() noexcept;
  const _RelFileNode* node;
  /**
   * 
   * @see _ForkNumber
   */
  const _ForkNumber::type* forkNum;
  const _BlockNumber* blocknum;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileTruncate_result {
 public:

  DataPageAccess_RpcFileTruncate_result(const DataPageAccess_RpcFileTruncate_result&);
  DataPageAccess_RpcFileTruncate_result& operator=(const DataPageAccess_RpcFileTruncate_result&);
  DataPageAccess_RpcFileTruncate_result() {
  }

  virtual ~DataPageAccess_RpcFileTruncate_result() noexcept;

  bool operator == (const DataPageAccess_RpcFileTruncate_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataPageAccess_RpcFileTruncate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_RpcFileTruncate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_RpcFileTruncate_presult {
 public:


  virtual ~DataPageAccess_RpcFileTruncate_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class DataPageAccess_zip_args {
 public:

  DataPageAccess_zip_args(const DataPageAccess_zip_args&);
  DataPageAccess_zip_args& operator=(const DataPageAccess_zip_args&);
  DataPageAccess_zip_args() {
  }

  virtual ~DataPageAccess_zip_args() noexcept;

  bool operator == (const DataPageAccess_zip_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DataPageAccess_zip_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageAccess_zip_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class DataPageAccess_zip_pargs {
 public:


  virtual ~DataPageAccess_zip_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class DataPageAccessClient : virtual public DataPageAccessIf {
 public:
  DataPageAccessClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  DataPageAccessClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param fd
   */
  void RpcFileClose(const File fd);
  void send_RpcFileClose(const File fd);
  void recv_RpcFileClose();
  File RpcFileCreate(const _RelFileNode& node, const _ForkNumber::type forkNum);
  void send_RpcFileCreate(const _RelFileNode& node, const _ForkNumber::type forkNum);
  File recv_RpcFileCreate();
  void RpcFileUnlink(const _RelFileNode& node, const _ForkNumber::type forkNum);
  void send_RpcFileUnlink(const _RelFileNode& node, const _ForkNumber::type forkNum);
  void recv_RpcFileUnlink();
  void RpcFileExtend(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum);
  void send_RpcFileExtend(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum);
  void recv_RpcFileExtend();
  void RpcFileRead(_Page& _return, const File fd, const _BlockNumber blocknum);
  void send_RpcFileRead(const File fd, const _BlockNumber blocknum);
  void recv_RpcFileRead(_Page& _return);
  void RpcFileWrite(const File fd, const _Page& page, const _BlockNumber blocknum);
  void send_RpcFileWrite(const File fd, const _Page& page, const _BlockNumber blocknum);
  void recv_RpcFileWrite();
  _BlockNumber RpcFileNblocks(const _RelFileNode& node, const _ForkNumber::type forkNum);
  void send_RpcFileNblocks(const _RelFileNode& node, const _ForkNumber::type forkNum);
  _BlockNumber recv_RpcFileNblocks();
  void RpcFileTruncate(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum);
  void send_RpcFileTruncate(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum);
  void recv_RpcFileTruncate();
  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  void zip();
  void send_zip();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class DataPageAccessProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<DataPageAccessIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (DataPageAccessProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_RpcFileClose(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcFileCreate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcFileUnlink(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcFileExtend(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcFileRead(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcFileWrite(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcFileNblocks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RpcFileTruncate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_zip(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  DataPageAccessProcessor(::std::shared_ptr<DataPageAccessIf> iface) :
    iface_(iface) {
    processMap_["RpcFileClose"] = &DataPageAccessProcessor::process_RpcFileClose;
    processMap_["RpcFileCreate"] = &DataPageAccessProcessor::process_RpcFileCreate;
    processMap_["RpcFileUnlink"] = &DataPageAccessProcessor::process_RpcFileUnlink;
    processMap_["RpcFileExtend"] = &DataPageAccessProcessor::process_RpcFileExtend;
    processMap_["RpcFileRead"] = &DataPageAccessProcessor::process_RpcFileRead;
    processMap_["RpcFileWrite"] = &DataPageAccessProcessor::process_RpcFileWrite;
    processMap_["RpcFileNblocks"] = &DataPageAccessProcessor::process_RpcFileNblocks;
    processMap_["RpcFileTruncate"] = &DataPageAccessProcessor::process_RpcFileTruncate;
    processMap_["zip"] = &DataPageAccessProcessor::process_zip;
  }

  virtual ~DataPageAccessProcessor() {}
};

class DataPageAccessProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  DataPageAccessProcessorFactory(const ::std::shared_ptr< DataPageAccessIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::std::shared_ptr< DataPageAccessIfFactory > handlerFactory_;
};

class DataPageAccessMultiface : virtual public DataPageAccessIf {
 public:
  DataPageAccessMultiface(std::vector<std::shared_ptr<DataPageAccessIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~DataPageAccessMultiface() {}
 protected:
  std::vector<std::shared_ptr<DataPageAccessIf> > ifaces_;
  DataPageAccessMultiface() {}
  void add(::std::shared_ptr<DataPageAccessIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param fd
   */
  void RpcFileClose(const File fd) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcFileClose(fd);
    }
    ifaces_[i]->RpcFileClose(fd);
  }

  File RpcFileCreate(const _RelFileNode& node, const _ForkNumber::type forkNum) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcFileCreate(node, forkNum);
    }
    return ifaces_[i]->RpcFileCreate(node, forkNum);
  }

  void RpcFileUnlink(const _RelFileNode& node, const _ForkNumber::type forkNum) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcFileUnlink(node, forkNum);
    }
    ifaces_[i]->RpcFileUnlink(node, forkNum);
  }

  void RpcFileExtend(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcFileExtend(node, forkNum, blocknum);
    }
    ifaces_[i]->RpcFileExtend(node, forkNum, blocknum);
  }

  void RpcFileRead(_Page& _return, const File fd, const _BlockNumber blocknum) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcFileRead(_return, fd, blocknum);
    }
    ifaces_[i]->RpcFileRead(_return, fd, blocknum);
    return;
  }

  void RpcFileWrite(const File fd, const _Page& page, const _BlockNumber blocknum) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcFileWrite(fd, page, blocknum);
    }
    ifaces_[i]->RpcFileWrite(fd, page, blocknum);
  }

  _BlockNumber RpcFileNblocks(const _RelFileNode& node, const _ForkNumber::type forkNum) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcFileNblocks(node, forkNum);
    }
    return ifaces_[i]->RpcFileNblocks(node, forkNum);
  }

  void RpcFileTruncate(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RpcFileTruncate(node, forkNum, blocknum);
    }
    ifaces_[i]->RpcFileTruncate(node, forkNum, blocknum);
  }

  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  void zip() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->zip();
    }
    ifaces_[i]->zip();
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class DataPageAccessConcurrentClient : virtual public DataPageAccessIf {
 public:
  DataPageAccessConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  DataPageAccessConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * A method definition looks like C code. It has a return type, arguments,
   * and optionally a list of exceptions that it may throw. Note that argument
   * lists and exception lists are specified using the exact same syntax as
   * field lists in struct or exception definitions.
   * 
   * @param fd
   */
  void RpcFileClose(const File fd);
  int32_t send_RpcFileClose(const File fd);
  void recv_RpcFileClose(const int32_t seqid);
  File RpcFileCreate(const _RelFileNode& node, const _ForkNumber::type forkNum);
  int32_t send_RpcFileCreate(const _RelFileNode& node, const _ForkNumber::type forkNum);
  File recv_RpcFileCreate(const int32_t seqid);
  void RpcFileUnlink(const _RelFileNode& node, const _ForkNumber::type forkNum);
  int32_t send_RpcFileUnlink(const _RelFileNode& node, const _ForkNumber::type forkNum);
  void recv_RpcFileUnlink(const int32_t seqid);
  void RpcFileExtend(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum);
  int32_t send_RpcFileExtend(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum);
  void recv_RpcFileExtend(const int32_t seqid);
  void RpcFileRead(_Page& _return, const File fd, const _BlockNumber blocknum);
  int32_t send_RpcFileRead(const File fd, const _BlockNumber blocknum);
  void recv_RpcFileRead(_Page& _return, const int32_t seqid);
  void RpcFileWrite(const File fd, const _Page& page, const _BlockNumber blocknum);
  int32_t send_RpcFileWrite(const File fd, const _Page& page, const _BlockNumber blocknum);
  void recv_RpcFileWrite(const int32_t seqid);
  _BlockNumber RpcFileNblocks(const _RelFileNode& node, const _ForkNumber::type forkNum);
  int32_t send_RpcFileNblocks(const _RelFileNode& node, const _ForkNumber::type forkNum);
  _BlockNumber recv_RpcFileNblocks(const int32_t seqid);
  void RpcFileTruncate(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum);
  int32_t send_RpcFileTruncate(const _RelFileNode& node, const _ForkNumber::type forkNum, const _BlockNumber blocknum);
  void recv_RpcFileTruncate(const int32_t seqid);
  /**
   * This method has a oneway modifier. That means the client only makes
   * a request and does not listen for any response at all. Oneway methods
   * must be void.
   */
  void zip();
  void send_zip();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

} // namespace

#endif
