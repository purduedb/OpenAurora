# Delve into LogIndex: What is it? How does it work?


## 1. What is LogIndex?

The logindex name is inherited from PolarDB for PostgreSQL. 
For PolarDB, the logindex is an index structure based on Hashmap,
which is used to quickly locate for a specific page, which logs are 
related with it.

## 2. How does LogIndex work?
### 2.1. Input of LogIndex
The input of LogIndex is the WAL record, which is generated by PostgreSQL
when a transaction is committed. The WAL record contains the information 
about which type of operation is performed, and which page is modified.
For each type of WAL record, there is a corresponding resource manager ("rmgr") to handle it.
There are 26 types of resource managers in PostgreSQL, and each of them has a unique ID.
These resource managers are defined in `src/include/access/rmgr.h`.

For example, there is a resource manager called `HEAP` for heap data.
If there is a WAL record aims to append a tuple to a heap table, the xlog record will mark
its resource manager as `HEAP`.

### 2.2 How to parse WAL record to LogIndex
As the StartupXLog function parsed a XLog, it will discern which resource manager is responsible for this XLog.
Then, it will call the corresponding function to parse the XLog. For example, if the resource manager is `HEAP`,
the function `polar_heap2_idx_save` will be called to parse the XLog.
Within the function `polar_heap2_idx_save`, `HEAP` resource manager will discern which type of operation is performed.
And this operation is also saved in the XLog.

After resource manager know the operation type, it will know whether this XLog should be replayed immediately or can
be delayed. For the most cases, the XLogs that are irrelevant with any pages should be replayed immediately, such as 
creating a new database, drop a table, etc. For these XLogs, the function `polar_heap2_idx_save` will return `false`,
and the StartupXLog function will call the corresponding resource manager again to replay the XLog immediately.

For the XLogs that are relevant with pages, the function `polar_heap2_idx_save` will parse which pages are related with this 
XLog, note that there may be multiple pages' information in one XLog. Then, the LSN will also be extracted from the XLog.
Then this forms a (or several) key-value pair (pageID->LSN). These key-value pairs will be inserted into the LogIndex.

### 2.3 The structure of LogIndex
The LogIndex is a hashmap, which is implemented by boost library. The key of the hashmap is the pageID, and the value is the LSN List.

Firstly, the LogIndex are divided into several buckets. The number of buckets is defined by the macro `LOG_INDEX_BUCKETS`.
The default value of `LOG_INDEX_BUCKETS` is 1024. The number of buckets is a prime number, which is used to avoid hash collision.

Each bucket has a mutex lock, which is used to protect the bucket. When a thread wants to access the bucket, it should acquire the lock first.

Inside each bucket, there is a head list. Each head corresponds to a pageID. Then one page's LSN will be inserted into the corresponding head. 
Since one page's LSN list can be unlimited long, we separate each page's LSN as a list. The header stores the metadata of this page, and also 
stores several LSNs. If the LSNs number exceeds the capacity of the header, the LSNs will be stored in the next node. The next node can also link
to another node, and so on. The last node will point to NULL.


## 3. When will we use LogIndex?
Firstly, when there is a new XLog arrives, the StartupXLog function will call the corresponding resource manager to parse the XLog. And 
then inserted the key-value pair (pageID->LSN) into the LogIndex.

Secondly, when a page is requested by a query, the function `polar_get_page` will be called. The rpc server will know this request's LSN.
And then it will check LogIndex to see which page version should be returned. If there is no page version in LogIndex, the rpc server will 
get the base version of this page from the storage node. If there is a page version in LogIndex, the rpc server will check whether the page
has been generated already. If not, the rpc server will get the latest version of this page, and also gather corresponding XLogs from the
storage (which also extracted from the LogIndex),  and then replay these XLogs to generate the page version. 

Thirdly, there is a background thread will replay the XLog asynchronously. This thread will check the LogIndex to see whether there is any
Xlog that can be replayed. If there is, the thread will replay the XLog. If not, the thread will sleep for a while, and then check again.



## 